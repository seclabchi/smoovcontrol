// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fmsmoov.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fmsmoov_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fmsmoov_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fmsmoov_2eproto;
namespace fmsmoov {
class GainGetCommand;
struct GainGetCommandDefaultTypeInternal;
extern GainGetCommandDefaultTypeInternal _GainGetCommand_default_instance_;
class GainGetResponse;
struct GainGetResponseDefaultTypeInternal;
extern GainGetResponseDefaultTypeInternal _GainGetResponse_default_instance_;
class GainPair;
struct GainPairDefaultTypeInternal;
extern GainPairDefaultTypeInternal _GainPair_default_instance_;
class GainSetCommand;
struct GainSetCommandDefaultTypeInternal;
extern GainSetCommandDefaultTypeInternal _GainSetCommand_default_instance_;
class InternalShutdownCommand;
struct InternalShutdownCommandDefaultTypeInternal;
extern InternalShutdownCommandDefaultTypeInternal _InternalShutdownCommand_default_instance_;
class MasterBypassGetCommand;
struct MasterBypassGetCommandDefaultTypeInternal;
extern MasterBypassGetCommandDefaultTypeInternal _MasterBypassGetCommand_default_instance_;
class MasterBypassGetResponse;
struct MasterBypassGetResponseDefaultTypeInternal;
extern MasterBypassGetResponseDefaultTypeInternal _MasterBypassGetResponse_default_instance_;
class MasterBypassSetCommand;
struct MasterBypassSetCommandDefaultTypeInternal;
extern MasterBypassSetCommandDefaultTypeInternal _MasterBypassSetCommand_default_instance_;
class MasterBypassSetResponse;
struct MasterBypassSetResponseDefaultTypeInternal;
extern MasterBypassSetResponseDefaultTypeInternal _MasterBypassSetResponse_default_instance_;
class ProcessorCommand;
struct ProcessorCommandDefaultTypeInternal;
extern ProcessorCommandDefaultTypeInternal _ProcessorCommand_default_instance_;
class ProcessorLiveData;
struct ProcessorLiveDataDefaultTypeInternal;
extern ProcessorLiveDataDefaultTypeInternal _ProcessorLiveData_default_instance_;
class ProcessorResponse;
struct ProcessorResponseDefaultTypeInternal;
extern ProcessorResponseDefaultTypeInternal _ProcessorResponse_default_instance_;
}  // namespace fmsmoov
PROTOBUF_NAMESPACE_OPEN
template<> ::fmsmoov::GainGetCommand* Arena::CreateMaybeMessage<::fmsmoov::GainGetCommand>(Arena*);
template<> ::fmsmoov::GainGetResponse* Arena::CreateMaybeMessage<::fmsmoov::GainGetResponse>(Arena*);
template<> ::fmsmoov::GainPair* Arena::CreateMaybeMessage<::fmsmoov::GainPair>(Arena*);
template<> ::fmsmoov::GainSetCommand* Arena::CreateMaybeMessage<::fmsmoov::GainSetCommand>(Arena*);
template<> ::fmsmoov::InternalShutdownCommand* Arena::CreateMaybeMessage<::fmsmoov::InternalShutdownCommand>(Arena*);
template<> ::fmsmoov::MasterBypassGetCommand* Arena::CreateMaybeMessage<::fmsmoov::MasterBypassGetCommand>(Arena*);
template<> ::fmsmoov::MasterBypassGetResponse* Arena::CreateMaybeMessage<::fmsmoov::MasterBypassGetResponse>(Arena*);
template<> ::fmsmoov::MasterBypassSetCommand* Arena::CreateMaybeMessage<::fmsmoov::MasterBypassSetCommand>(Arena*);
template<> ::fmsmoov::MasterBypassSetResponse* Arena::CreateMaybeMessage<::fmsmoov::MasterBypassSetResponse>(Arena*);
template<> ::fmsmoov::ProcessorCommand* Arena::CreateMaybeMessage<::fmsmoov::ProcessorCommand>(Arena*);
template<> ::fmsmoov::ProcessorLiveData* Arena::CreateMaybeMessage<::fmsmoov::ProcessorLiveData>(Arena*);
template<> ::fmsmoov::ProcessorResponse* Arena::CreateMaybeMessage<::fmsmoov::ProcessorResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fmsmoov {

enum GainType : int {
  LINEAR = 0,
  LOG = 1,
  GainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GainType_IsValid(int value);
constexpr GainType GainType_MIN = LINEAR;
constexpr GainType GainType_MAX = LOG;
constexpr int GainType_ARRAYSIZE = GainType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GainType_descriptor();
template<typename T>
inline const std::string& GainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GainType_descriptor(), enum_t_value);
}
inline bool GainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GainType>(
    GainType_descriptor(), name, value);
}
enum ResponseCode : int {
  OK = 0,
  ERROR = 1,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = OK;
constexpr ResponseCode ResponseCode_MAX = ERROR;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor();
template<typename T>
inline const std::string& ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCode_descriptor(), enum_t_value);
}
inline bool ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
// ===================================================================

class GainPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainPair) */ {
 public:
  inline GainPair() : GainPair(nullptr) {}
  ~GainPair() override;
  explicit constexpr GainPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainPair(const GainPair& from);
  GainPair(GainPair&& from) noexcept
    : GainPair() {
    *this = ::std::move(from);
  }

  inline GainPair& operator=(const GainPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainPair& operator=(GainPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const GainPair* internal_default_instance() {
    return reinterpret_cast<const GainPair*>(
               &_GainPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GainPair& a, GainPair& b) {
    a.Swap(&b);
  }
  inline void Swap(GainPair* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainPair* New() const final {
    return new GainPair();
  }

  GainPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainPair";
  }
  protected:
  explicit GainPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLFieldNumber = 1,
    kRFieldNumber = 2,
  };
  // float l = 1;
  void clear_l();
  float l() const;
  void set_l(float value);
  private:
  float _internal_l() const;
  void _internal_set_l(float value);
  public:

  // float r = 2;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.GainPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float l_;
  float r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorLiveData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorLiveData) */ {
 public:
  inline ProcessorLiveData() : ProcessorLiveData(nullptr) {}
  ~ProcessorLiveData() override;
  explicit constexpr ProcessorLiveData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorLiveData(const ProcessorLiveData& from);
  ProcessorLiveData(ProcessorLiveData&& from) noexcept
    : ProcessorLiveData() {
    *this = ::std::move(from);
  }

  inline ProcessorLiveData& operator=(const ProcessorLiveData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorLiveData& operator=(ProcessorLiveData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorLiveData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessorLiveData* internal_default_instance() {
    return reinterpret_cast<const ProcessorLiveData*>(
               &_ProcessorLiveData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProcessorLiveData& a, ProcessorLiveData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorLiveData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorLiveData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorLiveData* New() const final {
    return new ProcessorLiveData();
  }

  ProcessorLiveData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorLiveData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorLiveData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorLiveData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorLiveData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorLiveData";
  }
  protected:
  explicit ProcessorLiveData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInLFieldNumber = 2,
    kInRFieldNumber = 3,
    kOutLFieldNumber = 4,
    kOutRFieldNumber = 5,
  };
  // optional float inL = 2;
  bool has_inl() const;
  private:
  bool _internal_has_inl() const;
  public:
  void clear_inl();
  float inl() const;
  void set_inl(float value);
  private:
  float _internal_inl() const;
  void _internal_set_inl(float value);
  public:

  // optional float inR = 3;
  bool has_inr() const;
  private:
  bool _internal_has_inr() const;
  public:
  void clear_inr();
  float inr() const;
  void set_inr(float value);
  private:
  float _internal_inr() const;
  void _internal_set_inr(float value);
  public:

  // optional float outL = 4;
  bool has_outl() const;
  private:
  bool _internal_has_outl() const;
  public:
  void clear_outl();
  float outl() const;
  void set_outl(float value);
  private:
  float _internal_outl() const;
  void _internal_set_outl(float value);
  public:

  // optional float outR = 5;
  bool has_outr() const;
  private:
  bool _internal_has_outr() const;
  public:
  void clear_outr();
  float outr() const;
  void set_outr(float value);
  private:
  float _internal_outr() const;
  void _internal_set_outr(float value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorLiveData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float inl_;
  float inr_;
  float outl_;
  float outr_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class MasterBypassSetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.MasterBypassSetCommand) */ {
 public:
  inline MasterBypassSetCommand() : MasterBypassSetCommand(nullptr) {}
  ~MasterBypassSetCommand() override;
  explicit constexpr MasterBypassSetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterBypassSetCommand(const MasterBypassSetCommand& from);
  MasterBypassSetCommand(MasterBypassSetCommand&& from) noexcept
    : MasterBypassSetCommand() {
    *this = ::std::move(from);
  }

  inline MasterBypassSetCommand& operator=(const MasterBypassSetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterBypassSetCommand& operator=(MasterBypassSetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterBypassSetCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterBypassSetCommand* internal_default_instance() {
    return reinterpret_cast<const MasterBypassSetCommand*>(
               &_MasterBypassSetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MasterBypassSetCommand& a, MasterBypassSetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterBypassSetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterBypassSetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterBypassSetCommand* New() const final {
    return new MasterBypassSetCommand();
  }

  MasterBypassSetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterBypassSetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterBypassSetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterBypassSetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterBypassSetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.MasterBypassSetCommand";
  }
  protected:
  explicit MasterBypassSetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBypassFieldNumber = 1,
  };
  // bool bypass = 1;
  void clear_bypass();
  bool bypass() const;
  void set_bypass(bool value);
  private:
  bool _internal_bypass() const;
  void _internal_set_bypass(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.MasterBypassSetCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool bypass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class MasterBypassSetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.MasterBypassSetResponse) */ {
 public:
  inline MasterBypassSetResponse() : MasterBypassSetResponse(nullptr) {}
  ~MasterBypassSetResponse() override;
  explicit constexpr MasterBypassSetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterBypassSetResponse(const MasterBypassSetResponse& from);
  MasterBypassSetResponse(MasterBypassSetResponse&& from) noexcept
    : MasterBypassSetResponse() {
    *this = ::std::move(from);
  }

  inline MasterBypassSetResponse& operator=(const MasterBypassSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterBypassSetResponse& operator=(MasterBypassSetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterBypassSetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterBypassSetResponse* internal_default_instance() {
    return reinterpret_cast<const MasterBypassSetResponse*>(
               &_MasterBypassSetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MasterBypassSetResponse& a, MasterBypassSetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterBypassSetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterBypassSetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterBypassSetResponse* New() const final {
    return new MasterBypassSetResponse();
  }

  MasterBypassSetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterBypassSetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterBypassSetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterBypassSetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterBypassSetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.MasterBypassSetResponse";
  }
  protected:
  explicit MasterBypassSetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBypassFieldNumber = 1,
  };
  // bool bypass = 1;
  void clear_bypass();
  bool bypass() const;
  void set_bypass(bool value);
  private:
  bool _internal_bypass() const;
  void _internal_set_bypass(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.MasterBypassSetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool bypass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class MasterBypassGetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.MasterBypassGetCommand) */ {
 public:
  inline MasterBypassGetCommand() : MasterBypassGetCommand(nullptr) {}
  ~MasterBypassGetCommand() override;
  explicit constexpr MasterBypassGetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterBypassGetCommand(const MasterBypassGetCommand& from);
  MasterBypassGetCommand(MasterBypassGetCommand&& from) noexcept
    : MasterBypassGetCommand() {
    *this = ::std::move(from);
  }

  inline MasterBypassGetCommand& operator=(const MasterBypassGetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterBypassGetCommand& operator=(MasterBypassGetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterBypassGetCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterBypassGetCommand* internal_default_instance() {
    return reinterpret_cast<const MasterBypassGetCommand*>(
               &_MasterBypassGetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MasterBypassGetCommand& a, MasterBypassGetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterBypassGetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterBypassGetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterBypassGetCommand* New() const final {
    return new MasterBypassGetCommand();
  }

  MasterBypassGetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterBypassGetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterBypassGetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterBypassGetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterBypassGetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.MasterBypassGetCommand";
  }
  protected:
  explicit MasterBypassGetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fmsmoov.MasterBypassGetCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class MasterBypassGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.MasterBypassGetResponse) */ {
 public:
  inline MasterBypassGetResponse() : MasterBypassGetResponse(nullptr) {}
  ~MasterBypassGetResponse() override;
  explicit constexpr MasterBypassGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterBypassGetResponse(const MasterBypassGetResponse& from);
  MasterBypassGetResponse(MasterBypassGetResponse&& from) noexcept
    : MasterBypassGetResponse() {
    *this = ::std::move(from);
  }

  inline MasterBypassGetResponse& operator=(const MasterBypassGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterBypassGetResponse& operator=(MasterBypassGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterBypassGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterBypassGetResponse* internal_default_instance() {
    return reinterpret_cast<const MasterBypassGetResponse*>(
               &_MasterBypassGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MasterBypassGetResponse& a, MasterBypassGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterBypassGetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterBypassGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterBypassGetResponse* New() const final {
    return new MasterBypassGetResponse();
  }

  MasterBypassGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterBypassGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterBypassGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterBypassGetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterBypassGetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.MasterBypassGetResponse";
  }
  protected:
  explicit MasterBypassGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBypassFieldNumber = 1,
  };
  // bool bypass = 1;
  void clear_bypass();
  bool bypass() const;
  void set_bypass(bool value);
  private:
  bool _internal_bypass() const;
  void _internal_set_bypass(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.MasterBypassGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool bypass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class InternalShutdownCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.InternalShutdownCommand) */ {
 public:
  inline InternalShutdownCommand() : InternalShutdownCommand(nullptr) {}
  ~InternalShutdownCommand() override;
  explicit constexpr InternalShutdownCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalShutdownCommand(const InternalShutdownCommand& from);
  InternalShutdownCommand(InternalShutdownCommand&& from) noexcept
    : InternalShutdownCommand() {
    *this = ::std::move(from);
  }

  inline InternalShutdownCommand& operator=(const InternalShutdownCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalShutdownCommand& operator=(InternalShutdownCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalShutdownCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalShutdownCommand* internal_default_instance() {
    return reinterpret_cast<const InternalShutdownCommand*>(
               &_InternalShutdownCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InternalShutdownCommand& a, InternalShutdownCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalShutdownCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalShutdownCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InternalShutdownCommand* New() const final {
    return new InternalShutdownCommand();
  }

  InternalShutdownCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InternalShutdownCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalShutdownCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InternalShutdownCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalShutdownCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.InternalShutdownCommand";
  }
  protected:
  explicit InternalShutdownCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fmsmoov.InternalShutdownCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainSetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainSetCommand) */ {
 public:
  inline GainSetCommand() : GainSetCommand(nullptr) {}
  ~GainSetCommand() override;
  explicit constexpr GainSetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainSetCommand(const GainSetCommand& from);
  GainSetCommand(GainSetCommand&& from) noexcept
    : GainSetCommand() {
    *this = ::std::move(from);
  }

  inline GainSetCommand& operator=(const GainSetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainSetCommand& operator=(GainSetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainSetCommand& default_instance() {
    return *internal_default_instance();
  }
  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainSetCommand* internal_default_instance() {
    return reinterpret_cast<const GainSetCommand*>(
               &_GainSetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GainSetCommand& a, GainSetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GainSetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainSetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainSetCommand* New() const final {
    return new GainSetCommand();
  }

  GainSetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainSetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainSetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainSetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainSetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainSetCommand";
  }
  protected:
  explicit GainSetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
    kTypeFieldNumber = 4,
    kGainPairFieldNumber = 2,
    kGainFieldNumber = 3,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // .fmsmoov.GainType type = 4;
  void clear_type();
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);
  private:
  ::fmsmoov::GainType _internal_type() const;
  void _internal_set_type(::fmsmoov::GainType value);
  public:

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  private:
  bool _internal_has_gain_pair() const;
  public:
  void clear_gain_pair();
  const ::fmsmoov::GainPair& gain_pair() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainPair* release_gain_pair();
  ::fmsmoov::GainPair* mutable_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);
  private:
  const ::fmsmoov::GainPair& _internal_gain_pair() const;
  ::fmsmoov::GainPair* _internal_mutable_gain_pair();
  public:
  void unsafe_arena_set_allocated_gain_pair(
      ::fmsmoov::GainPair* gain_pair);
  ::fmsmoov::GainPair* unsafe_arena_release_gain_pair();

  // float gain = 3;
  bool has_gain() const;
  private:
  bool _internal_has_gain() const;
  public:
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  void clear_gaintype_oneof();
  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainSetCommand)
 private:
  class _Internal;
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  inline void clear_has_gaintype_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    constexpr GaintypeOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainGetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetCommand) */ {
 public:
  inline GainGetCommand() : GainGetCommand(nullptr) {}
  ~GainGetCommand() override;
  explicit constexpr GainGetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainGetCommand(const GainGetCommand& from);
  GainGetCommand(GainGetCommand&& from) noexcept
    : GainGetCommand() {
    *this = ::std::move(from);
  }

  inline GainGetCommand& operator=(const GainGetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainGetCommand& operator=(GainGetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainGetCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const GainGetCommand* internal_default_instance() {
    return reinterpret_cast<const GainGetCommand*>(
               &_GainGetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GainGetCommand& a, GainGetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GainGetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainGetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainGetCommand* New() const final {
    return new GainGetCommand();
  }

  GainGetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainGetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainGetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainGetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainGetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainGetCommand";
  }
  protected:
  explicit GainGetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetResponse) */ {
 public:
  inline GainGetResponse() : GainGetResponse(nullptr) {}
  ~GainGetResponse() override;
  explicit constexpr GainGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainGetResponse(const GainGetResponse& from);
  GainGetResponse(GainGetResponse&& from) noexcept
    : GainGetResponse() {
    *this = ::std::move(from);
  }

  inline GainGetResponse& operator=(const GainGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainGetResponse& operator=(GainGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainGetResponse& default_instance() {
    return *internal_default_instance();
  }
  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainGetResponse* internal_default_instance() {
    return reinterpret_cast<const GainGetResponse*>(
               &_GainGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GainGetResponse& a, GainGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GainGetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainGetResponse* New() const final {
    return new GainGetResponse();
  }

  GainGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainGetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainGetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainGetResponse";
  }
  protected:
  explicit GainGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
    kTypeFieldNumber = 4,
    kGainPairFieldNumber = 2,
    kGainFieldNumber = 3,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // .fmsmoov.GainType type = 4;
  void clear_type();
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);
  private:
  ::fmsmoov::GainType _internal_type() const;
  void _internal_set_type(::fmsmoov::GainType value);
  public:

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  private:
  bool _internal_has_gain_pair() const;
  public:
  void clear_gain_pair();
  const ::fmsmoov::GainPair& gain_pair() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainPair* release_gain_pair();
  ::fmsmoov::GainPair* mutable_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);
  private:
  const ::fmsmoov::GainPair& _internal_gain_pair() const;
  ::fmsmoov::GainPair* _internal_mutable_gain_pair();
  public:
  void unsafe_arena_set_allocated_gain_pair(
      ::fmsmoov::GainPair* gain_pair);
  ::fmsmoov::GainPair* unsafe_arena_release_gain_pair();

  // float gain = 3;
  bool has_gain() const;
  private:
  bool _internal_has_gain() const;
  public:
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  void clear_gaintype_oneof();
  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetResponse)
 private:
  class _Internal;
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  inline void clear_has_gaintype_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    constexpr GaintypeOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorCommand) */ {
 public:
  inline ProcessorCommand() : ProcessorCommand(nullptr) {}
  ~ProcessorCommand() override;
  explicit constexpr ProcessorCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorCommand(const ProcessorCommand& from);
  ProcessorCommand(ProcessorCommand&& from) noexcept
    : ProcessorCommand() {
    *this = ::std::move(from);
  }

  inline ProcessorCommand& operator=(const ProcessorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorCommand& operator=(ProcessorCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CmdOneofCase {
    kInternalShutdownCmd = 1,
    kMasterBypassSet = 2,
    kMasterBypassGet = 3,
    kGainSet = 4,
    kGainGet = 5,
    CMD_ONEOF_NOT_SET = 0,
  };

  static inline const ProcessorCommand* internal_default_instance() {
    return reinterpret_cast<const ProcessorCommand*>(
               &_ProcessorCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProcessorCommand& a, ProcessorCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorCommand* New() const final {
    return new ProcessorCommand();
  }

  ProcessorCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorCommand";
  }
  protected:
  explicit ProcessorCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternalShutdownCmdFieldNumber = 1,
    kMasterBypassSetFieldNumber = 2,
    kMasterBypassGetFieldNumber = 3,
    kGainSetFieldNumber = 4,
    kGainGetFieldNumber = 5,
  };
  // .fmsmoov.InternalShutdownCommand internal_shutdown_cmd = 1;
  bool has_internal_shutdown_cmd() const;
  private:
  bool _internal_has_internal_shutdown_cmd() const;
  public:
  void clear_internal_shutdown_cmd();
  const ::fmsmoov::InternalShutdownCommand& internal_shutdown_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::InternalShutdownCommand* release_internal_shutdown_cmd();
  ::fmsmoov::InternalShutdownCommand* mutable_internal_shutdown_cmd();
  void set_allocated_internal_shutdown_cmd(::fmsmoov::InternalShutdownCommand* internal_shutdown_cmd);
  private:
  const ::fmsmoov::InternalShutdownCommand& _internal_internal_shutdown_cmd() const;
  ::fmsmoov::InternalShutdownCommand* _internal_mutable_internal_shutdown_cmd();
  public:
  void unsafe_arena_set_allocated_internal_shutdown_cmd(
      ::fmsmoov::InternalShutdownCommand* internal_shutdown_cmd);
  ::fmsmoov::InternalShutdownCommand* unsafe_arena_release_internal_shutdown_cmd();

  // .fmsmoov.MasterBypassSetCommand master_bypass_set = 2;
  bool has_master_bypass_set() const;
  private:
  bool _internal_has_master_bypass_set() const;
  public:
  void clear_master_bypass_set();
  const ::fmsmoov::MasterBypassSetCommand& master_bypass_set() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::MasterBypassSetCommand* release_master_bypass_set();
  ::fmsmoov::MasterBypassSetCommand* mutable_master_bypass_set();
  void set_allocated_master_bypass_set(::fmsmoov::MasterBypassSetCommand* master_bypass_set);
  private:
  const ::fmsmoov::MasterBypassSetCommand& _internal_master_bypass_set() const;
  ::fmsmoov::MasterBypassSetCommand* _internal_mutable_master_bypass_set();
  public:
  void unsafe_arena_set_allocated_master_bypass_set(
      ::fmsmoov::MasterBypassSetCommand* master_bypass_set);
  ::fmsmoov::MasterBypassSetCommand* unsafe_arena_release_master_bypass_set();

  // .fmsmoov.MasterBypassGetCommand master_bypass_get = 3;
  bool has_master_bypass_get() const;
  private:
  bool _internal_has_master_bypass_get() const;
  public:
  void clear_master_bypass_get();
  const ::fmsmoov::MasterBypassGetCommand& master_bypass_get() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::MasterBypassGetCommand* release_master_bypass_get();
  ::fmsmoov::MasterBypassGetCommand* mutable_master_bypass_get();
  void set_allocated_master_bypass_get(::fmsmoov::MasterBypassGetCommand* master_bypass_get);
  private:
  const ::fmsmoov::MasterBypassGetCommand& _internal_master_bypass_get() const;
  ::fmsmoov::MasterBypassGetCommand* _internal_mutable_master_bypass_get();
  public:
  void unsafe_arena_set_allocated_master_bypass_get(
      ::fmsmoov::MasterBypassGetCommand* master_bypass_get);
  ::fmsmoov::MasterBypassGetCommand* unsafe_arena_release_master_bypass_get();

  // .fmsmoov.GainSetCommand gain_set = 4;
  bool has_gain_set() const;
  private:
  bool _internal_has_gain_set() const;
  public:
  void clear_gain_set();
  const ::fmsmoov::GainSetCommand& gain_set() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainSetCommand* release_gain_set();
  ::fmsmoov::GainSetCommand* mutable_gain_set();
  void set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set);
  private:
  const ::fmsmoov::GainSetCommand& _internal_gain_set() const;
  ::fmsmoov::GainSetCommand* _internal_mutable_gain_set();
  public:
  void unsafe_arena_set_allocated_gain_set(
      ::fmsmoov::GainSetCommand* gain_set);
  ::fmsmoov::GainSetCommand* unsafe_arena_release_gain_set();

  // .fmsmoov.GainGetCommand gain_get = 5;
  bool has_gain_get() const;
  private:
  bool _internal_has_gain_get() const;
  public:
  void clear_gain_get();
  const ::fmsmoov::GainGetCommand& gain_get() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainGetCommand* release_gain_get();
  ::fmsmoov::GainGetCommand* mutable_gain_get();
  void set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get);
  private:
  const ::fmsmoov::GainGetCommand& _internal_gain_get() const;
  ::fmsmoov::GainGetCommand* _internal_mutable_gain_get();
  public:
  void unsafe_arena_set_allocated_gain_get(
      ::fmsmoov::GainGetCommand* gain_get);
  ::fmsmoov::GainGetCommand* unsafe_arena_release_gain_get();

  void clear_cmd_oneof();
  CmdOneofCase cmd_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorCommand)
 private:
  class _Internal;
  void set_has_internal_shutdown_cmd();
  void set_has_master_bypass_set();
  void set_has_master_bypass_get();
  void set_has_gain_set();
  void set_has_gain_get();

  inline bool has_cmd_oneof() const;
  inline void clear_has_cmd_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CmdOneofUnion {
    constexpr CmdOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::InternalShutdownCommand* internal_shutdown_cmd_;
    ::fmsmoov::MasterBypassSetCommand* master_bypass_set_;
    ::fmsmoov::MasterBypassGetCommand* master_bypass_get_;
    ::fmsmoov::GainSetCommand* gain_set_;
    ::fmsmoov::GainGetCommand* gain_get_;
  } cmd_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorResponse) */ {
 public:
  inline ProcessorResponse() : ProcessorResponse(nullptr) {}
  ~ProcessorResponse() override;
  explicit constexpr ProcessorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorResponse(const ProcessorResponse& from);
  ProcessorResponse(ProcessorResponse&& from) noexcept
    : ProcessorResponse() {
    *this = ::std::move(from);
  }

  inline ProcessorResponse& operator=(const ProcessorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorResponse& operator=(ProcessorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessorResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessorResponse*>(
               &_ProcessorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProcessorResponse& a, ProcessorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorResponse* New() const final {
    return new ProcessorResponse();
  }

  ProcessorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorResponse";
  }
  protected:
  explicit ProcessorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseMsgFieldNumber = 2,
    kMasterBypassSetRspFieldNumber = 3,
    kMasterBypassGetRspFieldNumber = 4,
    kGainGetRspFieldNumber = 5,
    kResponseFieldNumber = 1,
  };
  // string response_msg = 2;
  void clear_response_msg();
  const std::string& response_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_response_msg();
  void set_allocated_response_msg(std::string* response_msg);
  private:
  const std::string& _internal_response_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_msg(const std::string& value);
  std::string* _internal_mutable_response_msg();
  public:

  // optional .fmsmoov.MasterBypassSetResponse master_bypass_set_rsp = 3;
  bool has_master_bypass_set_rsp() const;
  private:
  bool _internal_has_master_bypass_set_rsp() const;
  public:
  void clear_master_bypass_set_rsp();
  const ::fmsmoov::MasterBypassSetResponse& master_bypass_set_rsp() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::MasterBypassSetResponse* release_master_bypass_set_rsp();
  ::fmsmoov::MasterBypassSetResponse* mutable_master_bypass_set_rsp();
  void set_allocated_master_bypass_set_rsp(::fmsmoov::MasterBypassSetResponse* master_bypass_set_rsp);
  private:
  const ::fmsmoov::MasterBypassSetResponse& _internal_master_bypass_set_rsp() const;
  ::fmsmoov::MasterBypassSetResponse* _internal_mutable_master_bypass_set_rsp();
  public:
  void unsafe_arena_set_allocated_master_bypass_set_rsp(
      ::fmsmoov::MasterBypassSetResponse* master_bypass_set_rsp);
  ::fmsmoov::MasterBypassSetResponse* unsafe_arena_release_master_bypass_set_rsp();

  // optional .fmsmoov.MasterBypassGetResponse master_bypass_get_rsp = 4;
  bool has_master_bypass_get_rsp() const;
  private:
  bool _internal_has_master_bypass_get_rsp() const;
  public:
  void clear_master_bypass_get_rsp();
  const ::fmsmoov::MasterBypassGetResponse& master_bypass_get_rsp() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::MasterBypassGetResponse* release_master_bypass_get_rsp();
  ::fmsmoov::MasterBypassGetResponse* mutable_master_bypass_get_rsp();
  void set_allocated_master_bypass_get_rsp(::fmsmoov::MasterBypassGetResponse* master_bypass_get_rsp);
  private:
  const ::fmsmoov::MasterBypassGetResponse& _internal_master_bypass_get_rsp() const;
  ::fmsmoov::MasterBypassGetResponse* _internal_mutable_master_bypass_get_rsp();
  public:
  void unsafe_arena_set_allocated_master_bypass_get_rsp(
      ::fmsmoov::MasterBypassGetResponse* master_bypass_get_rsp);
  ::fmsmoov::MasterBypassGetResponse* unsafe_arena_release_master_bypass_get_rsp();

  // optional .fmsmoov.GainGetResponse gain_get_rsp = 5;
  bool has_gain_get_rsp() const;
  private:
  bool _internal_has_gain_get_rsp() const;
  public:
  void clear_gain_get_rsp();
  const ::fmsmoov::GainGetResponse& gain_get_rsp() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainGetResponse* release_gain_get_rsp();
  ::fmsmoov::GainGetResponse* mutable_gain_get_rsp();
  void set_allocated_gain_get_rsp(::fmsmoov::GainGetResponse* gain_get_rsp);
  private:
  const ::fmsmoov::GainGetResponse& _internal_gain_get_rsp() const;
  ::fmsmoov::GainGetResponse* _internal_mutable_gain_get_rsp();
  public:
  void unsafe_arena_set_allocated_gain_get_rsp(
      ::fmsmoov::GainGetResponse* gain_get_rsp);
  ::fmsmoov::GainGetResponse* unsafe_arena_release_gain_get_rsp();

  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);
  private:
  ::fmsmoov::ResponseCode _internal_response() const;
  void _internal_set_response(::fmsmoov::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_msg_;
  ::fmsmoov::MasterBypassSetResponse* master_bypass_set_rsp_;
  ::fmsmoov::MasterBypassGetResponse* master_bypass_get_rsp_;
  ::fmsmoov::GainGetResponse* gain_get_rsp_;
  int response_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GainPair

// float l = 1;
inline void GainPair::clear_l() {
  l_ = 0;
}
inline float GainPair::_internal_l() const {
  return l_;
}
inline float GainPair::l() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.l)
  return _internal_l();
}
inline void GainPair::_internal_set_l(float value) {
  
  l_ = value;
}
inline void GainPair::set_l(float value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.l)
}

// float r = 2;
inline void GainPair::clear_r() {
  r_ = 0;
}
inline float GainPair::_internal_r() const {
  return r_;
}
inline float GainPair::r() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.r)
  return _internal_r();
}
inline void GainPair::_internal_set_r(float value) {
  
  r_ = value;
}
inline void GainPair::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.r)
}

// -------------------------------------------------------------------

// ProcessorLiveData

// optional float inL = 2;
inline bool ProcessorLiveData::_internal_has_inl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_inl() const {
  return _internal_has_inl();
}
inline void ProcessorLiveData::clear_inl() {
  inl_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ProcessorLiveData::_internal_inl() const {
  return inl_;
}
inline float ProcessorLiveData::inl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inL)
  return _internal_inl();
}
inline void ProcessorLiveData::_internal_set_inl(float value) {
  _has_bits_[0] |= 0x00000001u;
  inl_ = value;
}
inline void ProcessorLiveData::set_inl(float value) {
  _internal_set_inl(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inL)
}

// optional float inR = 3;
inline bool ProcessorLiveData::_internal_has_inr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_inr() const {
  return _internal_has_inr();
}
inline void ProcessorLiveData::clear_inr() {
  inr_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ProcessorLiveData::_internal_inr() const {
  return inr_;
}
inline float ProcessorLiveData::inr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inR)
  return _internal_inr();
}
inline void ProcessorLiveData::_internal_set_inr(float value) {
  _has_bits_[0] |= 0x00000002u;
  inr_ = value;
}
inline void ProcessorLiveData::set_inr(float value) {
  _internal_set_inr(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inR)
}

// optional float outL = 4;
inline bool ProcessorLiveData::_internal_has_outl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_outl() const {
  return _internal_has_outl();
}
inline void ProcessorLiveData::clear_outl() {
  outl_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ProcessorLiveData::_internal_outl() const {
  return outl_;
}
inline float ProcessorLiveData::outl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outL)
  return _internal_outl();
}
inline void ProcessorLiveData::_internal_set_outl(float value) {
  _has_bits_[0] |= 0x00000004u;
  outl_ = value;
}
inline void ProcessorLiveData::set_outl(float value) {
  _internal_set_outl(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outL)
}

// optional float outR = 5;
inline bool ProcessorLiveData::_internal_has_outr() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_outr() const {
  return _internal_has_outr();
}
inline void ProcessorLiveData::clear_outr() {
  outr_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ProcessorLiveData::_internal_outr() const {
  return outr_;
}
inline float ProcessorLiveData::outr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outR)
  return _internal_outr();
}
inline void ProcessorLiveData::_internal_set_outr(float value) {
  _has_bits_[0] |= 0x00000008u;
  outr_ = value;
}
inline void ProcessorLiveData::set_outr(float value) {
  _internal_set_outr(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outR)
}

// -------------------------------------------------------------------

// MasterBypassSetCommand

// bool bypass = 1;
inline void MasterBypassSetCommand::clear_bypass() {
  bypass_ = false;
}
inline bool MasterBypassSetCommand::_internal_bypass() const {
  return bypass_;
}
inline bool MasterBypassSetCommand::bypass() const {
  // @@protoc_insertion_point(field_get:fmsmoov.MasterBypassSetCommand.bypass)
  return _internal_bypass();
}
inline void MasterBypassSetCommand::_internal_set_bypass(bool value) {
  
  bypass_ = value;
}
inline void MasterBypassSetCommand::set_bypass(bool value) {
  _internal_set_bypass(value);
  // @@protoc_insertion_point(field_set:fmsmoov.MasterBypassSetCommand.bypass)
}

// -------------------------------------------------------------------

// MasterBypassSetResponse

// bool bypass = 1;
inline void MasterBypassSetResponse::clear_bypass() {
  bypass_ = false;
}
inline bool MasterBypassSetResponse::_internal_bypass() const {
  return bypass_;
}
inline bool MasterBypassSetResponse::bypass() const {
  // @@protoc_insertion_point(field_get:fmsmoov.MasterBypassSetResponse.bypass)
  return _internal_bypass();
}
inline void MasterBypassSetResponse::_internal_set_bypass(bool value) {
  
  bypass_ = value;
}
inline void MasterBypassSetResponse::set_bypass(bool value) {
  _internal_set_bypass(value);
  // @@protoc_insertion_point(field_set:fmsmoov.MasterBypassSetResponse.bypass)
}

// -------------------------------------------------------------------

// MasterBypassGetCommand

// -------------------------------------------------------------------

// MasterBypassGetResponse

// bool bypass = 1;
inline void MasterBypassGetResponse::clear_bypass() {
  bypass_ = false;
}
inline bool MasterBypassGetResponse::_internal_bypass() const {
  return bypass_;
}
inline bool MasterBypassGetResponse::bypass() const {
  // @@protoc_insertion_point(field_get:fmsmoov.MasterBypassGetResponse.bypass)
  return _internal_bypass();
}
inline void MasterBypassGetResponse::_internal_set_bypass(bool value) {
  
  bypass_ = value;
}
inline void MasterBypassGetResponse::set_bypass(bool value) {
  _internal_set_bypass(value);
  // @@protoc_insertion_point(field_set:fmsmoov.MasterBypassGetResponse.bypass)
}

// -------------------------------------------------------------------

// InternalShutdownCommand

// -------------------------------------------------------------------

// GainSetCommand

// string which = 1;
inline void GainSetCommand::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainSetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainSetCommand::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.which)
}
inline std::string* GainSetCommand::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.which)
  return _s;
}
inline const std::string& GainSetCommand::_internal_which() const {
  return which_.Get();
}
inline void GainSetCommand::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainSetCommand::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainSetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainSetCommand::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainSetCommand.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainSetCommand::_internal_has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline bool GainSetCommand::has_gain_pair() const {
  return _internal_has_gain_pair();
}
inline void GainSetCommand::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainSetCommand::clear_gain_pair() {
  if (_internal_has_gain_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete gaintype_oneof_.gain_pair_;
    }
    clear_has_gaintype_oneof();
  }
}
inline ::fmsmoov::GainPair* GainSetCommand::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
      ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainPair& GainSetCommand::_internal_gain_pair() const {
  return _internal_has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : reinterpret_cast< ::fmsmoov::GainPair&>(::fmsmoov::_GainPair_default_instance_);
}
inline const ::fmsmoov::GainPair& GainSetCommand::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain_pair)
  return _internal_gain_pair();
}
inline ::fmsmoov::GainPair* GainSetCommand::unsafe_arena_release_gain_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.GainSetCommand.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GainSetCommand::unsafe_arena_set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.GainSetCommand.gain_pair)
}
inline ::fmsmoov::GainPair* GainSetCommand::_internal_mutable_gain_pair() {
  if (!_internal_has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = CreateMaybeMessage< ::fmsmoov::GainPair >(GetArenaForAllocation());
  }
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainSetCommand::mutable_gain_pair() {
  ::fmsmoov::GainPair* _msg = _internal_mutable_gain_pair();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.gain_pair)
  return _msg;
}

// float gain = 3;
inline bool GainSetCommand::_internal_has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline bool GainSetCommand::has_gain() const {
  return _internal_has_gain();
}
inline void GainSetCommand::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainSetCommand::clear_gain() {
  if (_internal_has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainSetCommand::_internal_gain() const {
  if (_internal_has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainSetCommand::_internal_set_gain(float value) {
  if (!_internal_has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
}
inline float GainSetCommand::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain)
  return _internal_gain();
}
inline void GainSetCommand::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainSetCommand::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainSetCommand::_internal_type() const {
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline ::fmsmoov::GainType GainSetCommand::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.type)
  return _internal_type();
}
inline void GainSetCommand::_internal_set_type(::fmsmoov::GainType value) {
  
  type_ = value;
}
inline void GainSetCommand::set_type(::fmsmoov::GainType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.type)
}

inline bool GainSetCommand::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainSetCommand::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainSetCommand::GaintypeOneofCase GainSetCommand::gaintype_oneof_case() const {
  return GainSetCommand::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GainGetCommand

// string which = 1;
inline void GainGetCommand::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainGetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetCommand.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainGetCommand::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetCommand.which)
}
inline std::string* GainGetCommand::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetCommand.which)
  return _s;
}
inline const std::string& GainGetCommand::_internal_which() const {
  return which_.Get();
}
inline void GainGetCommand::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainGetCommand::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainGetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetCommand.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainGetCommand::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetCommand.which)
}

// -------------------------------------------------------------------

// GainGetResponse

// string which = 1;
inline void GainGetResponse::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainGetResponse::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainGetResponse::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.which)
}
inline std::string* GainGetResponse::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.which)
  return _s;
}
inline const std::string& GainGetResponse::_internal_which() const {
  return which_.Get();
}
inline void GainGetResponse::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainGetResponse::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainGetResponse::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainGetResponse::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetResponse.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainGetResponse::_internal_has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline bool GainGetResponse::has_gain_pair() const {
  return _internal_has_gain_pair();
}
inline void GainGetResponse::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainGetResponse::clear_gain_pair() {
  if (_internal_has_gain_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete gaintype_oneof_.gain_pair_;
    }
    clear_has_gaintype_oneof();
  }
}
inline ::fmsmoov::GainPair* GainGetResponse::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
      ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainPair& GainGetResponse::_internal_gain_pair() const {
  return _internal_has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : reinterpret_cast< ::fmsmoov::GainPair&>(::fmsmoov::_GainPair_default_instance_);
}
inline const ::fmsmoov::GainPair& GainGetResponse::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain_pair)
  return _internal_gain_pair();
}
inline ::fmsmoov::GainPair* GainGetResponse::unsafe_arena_release_gain_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.GainGetResponse.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GainGetResponse::unsafe_arena_set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.GainGetResponse.gain_pair)
}
inline ::fmsmoov::GainPair* GainGetResponse::_internal_mutable_gain_pair() {
  if (!_internal_has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = CreateMaybeMessage< ::fmsmoov::GainPair >(GetArenaForAllocation());
  }
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainGetResponse::mutable_gain_pair() {
  ::fmsmoov::GainPair* _msg = _internal_mutable_gain_pair();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.gain_pair)
  return _msg;
}

// float gain = 3;
inline bool GainGetResponse::_internal_has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline bool GainGetResponse::has_gain() const {
  return _internal_has_gain();
}
inline void GainGetResponse::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainGetResponse::clear_gain() {
  if (_internal_has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainGetResponse::_internal_gain() const {
  if (_internal_has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainGetResponse::_internal_set_gain(float value) {
  if (!_internal_has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
}
inline float GainGetResponse::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain)
  return _internal_gain();
}
inline void GainGetResponse::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainGetResponse::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainGetResponse::_internal_type() const {
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline ::fmsmoov::GainType GainGetResponse::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.type)
  return _internal_type();
}
inline void GainGetResponse::_internal_set_type(::fmsmoov::GainType value) {
  
  type_ = value;
}
inline void GainGetResponse::set_type(::fmsmoov::GainType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.type)
}

inline bool GainGetResponse::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainGetResponse::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainGetResponse::GaintypeOneofCase GainGetResponse::gaintype_oneof_case() const {
  return GainGetResponse::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorCommand

// .fmsmoov.InternalShutdownCommand internal_shutdown_cmd = 1;
inline bool ProcessorCommand::_internal_has_internal_shutdown_cmd() const {
  return cmd_oneof_case() == kInternalShutdownCmd;
}
inline bool ProcessorCommand::has_internal_shutdown_cmd() const {
  return _internal_has_internal_shutdown_cmd();
}
inline void ProcessorCommand::set_has_internal_shutdown_cmd() {
  _oneof_case_[0] = kInternalShutdownCmd;
}
inline void ProcessorCommand::clear_internal_shutdown_cmd() {
  if (_internal_has_internal_shutdown_cmd()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.internal_shutdown_cmd_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::InternalShutdownCommand* ProcessorCommand::release_internal_shutdown_cmd() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.internal_shutdown_cmd)
  if (_internal_has_internal_shutdown_cmd()) {
    clear_has_cmd_oneof();
      ::fmsmoov::InternalShutdownCommand* temp = cmd_oneof_.internal_shutdown_cmd_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.internal_shutdown_cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::InternalShutdownCommand& ProcessorCommand::_internal_internal_shutdown_cmd() const {
  return _internal_has_internal_shutdown_cmd()
      ? *cmd_oneof_.internal_shutdown_cmd_
      : reinterpret_cast< ::fmsmoov::InternalShutdownCommand&>(::fmsmoov::_InternalShutdownCommand_default_instance_);
}
inline const ::fmsmoov::InternalShutdownCommand& ProcessorCommand::internal_shutdown_cmd() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.internal_shutdown_cmd)
  return _internal_internal_shutdown_cmd();
}
inline ::fmsmoov::InternalShutdownCommand* ProcessorCommand::unsafe_arena_release_internal_shutdown_cmd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.internal_shutdown_cmd)
  if (_internal_has_internal_shutdown_cmd()) {
    clear_has_cmd_oneof();
    ::fmsmoov::InternalShutdownCommand* temp = cmd_oneof_.internal_shutdown_cmd_;
    cmd_oneof_.internal_shutdown_cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_internal_shutdown_cmd(::fmsmoov::InternalShutdownCommand* internal_shutdown_cmd) {
  clear_cmd_oneof();
  if (internal_shutdown_cmd) {
    set_has_internal_shutdown_cmd();
    cmd_oneof_.internal_shutdown_cmd_ = internal_shutdown_cmd;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.internal_shutdown_cmd)
}
inline ::fmsmoov::InternalShutdownCommand* ProcessorCommand::_internal_mutable_internal_shutdown_cmd() {
  if (!_internal_has_internal_shutdown_cmd()) {
    clear_cmd_oneof();
    set_has_internal_shutdown_cmd();
    cmd_oneof_.internal_shutdown_cmd_ = CreateMaybeMessage< ::fmsmoov::InternalShutdownCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.internal_shutdown_cmd_;
}
inline ::fmsmoov::InternalShutdownCommand* ProcessorCommand::mutable_internal_shutdown_cmd() {
  ::fmsmoov::InternalShutdownCommand* _msg = _internal_mutable_internal_shutdown_cmd();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.internal_shutdown_cmd)
  return _msg;
}

// .fmsmoov.MasterBypassSetCommand master_bypass_set = 2;
inline bool ProcessorCommand::_internal_has_master_bypass_set() const {
  return cmd_oneof_case() == kMasterBypassSet;
}
inline bool ProcessorCommand::has_master_bypass_set() const {
  return _internal_has_master_bypass_set();
}
inline void ProcessorCommand::set_has_master_bypass_set() {
  _oneof_case_[0] = kMasterBypassSet;
}
inline void ProcessorCommand::clear_master_bypass_set() {
  if (_internal_has_master_bypass_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.master_bypass_set_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::MasterBypassSetCommand* ProcessorCommand::release_master_bypass_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.master_bypass_set)
  if (_internal_has_master_bypass_set()) {
    clear_has_cmd_oneof();
      ::fmsmoov::MasterBypassSetCommand* temp = cmd_oneof_.master_bypass_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.master_bypass_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::MasterBypassSetCommand& ProcessorCommand::_internal_master_bypass_set() const {
  return _internal_has_master_bypass_set()
      ? *cmd_oneof_.master_bypass_set_
      : reinterpret_cast< ::fmsmoov::MasterBypassSetCommand&>(::fmsmoov::_MasterBypassSetCommand_default_instance_);
}
inline const ::fmsmoov::MasterBypassSetCommand& ProcessorCommand::master_bypass_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.master_bypass_set)
  return _internal_master_bypass_set();
}
inline ::fmsmoov::MasterBypassSetCommand* ProcessorCommand::unsafe_arena_release_master_bypass_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.master_bypass_set)
  if (_internal_has_master_bypass_set()) {
    clear_has_cmd_oneof();
    ::fmsmoov::MasterBypassSetCommand* temp = cmd_oneof_.master_bypass_set_;
    cmd_oneof_.master_bypass_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_master_bypass_set(::fmsmoov::MasterBypassSetCommand* master_bypass_set) {
  clear_cmd_oneof();
  if (master_bypass_set) {
    set_has_master_bypass_set();
    cmd_oneof_.master_bypass_set_ = master_bypass_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.master_bypass_set)
}
inline ::fmsmoov::MasterBypassSetCommand* ProcessorCommand::_internal_mutable_master_bypass_set() {
  if (!_internal_has_master_bypass_set()) {
    clear_cmd_oneof();
    set_has_master_bypass_set();
    cmd_oneof_.master_bypass_set_ = CreateMaybeMessage< ::fmsmoov::MasterBypassSetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.master_bypass_set_;
}
inline ::fmsmoov::MasterBypassSetCommand* ProcessorCommand::mutable_master_bypass_set() {
  ::fmsmoov::MasterBypassSetCommand* _msg = _internal_mutable_master_bypass_set();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.master_bypass_set)
  return _msg;
}

// .fmsmoov.MasterBypassGetCommand master_bypass_get = 3;
inline bool ProcessorCommand::_internal_has_master_bypass_get() const {
  return cmd_oneof_case() == kMasterBypassGet;
}
inline bool ProcessorCommand::has_master_bypass_get() const {
  return _internal_has_master_bypass_get();
}
inline void ProcessorCommand::set_has_master_bypass_get() {
  _oneof_case_[0] = kMasterBypassGet;
}
inline void ProcessorCommand::clear_master_bypass_get() {
  if (_internal_has_master_bypass_get()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.master_bypass_get_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::MasterBypassGetCommand* ProcessorCommand::release_master_bypass_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.master_bypass_get)
  if (_internal_has_master_bypass_get()) {
    clear_has_cmd_oneof();
      ::fmsmoov::MasterBypassGetCommand* temp = cmd_oneof_.master_bypass_get_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.master_bypass_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::MasterBypassGetCommand& ProcessorCommand::_internal_master_bypass_get() const {
  return _internal_has_master_bypass_get()
      ? *cmd_oneof_.master_bypass_get_
      : reinterpret_cast< ::fmsmoov::MasterBypassGetCommand&>(::fmsmoov::_MasterBypassGetCommand_default_instance_);
}
inline const ::fmsmoov::MasterBypassGetCommand& ProcessorCommand::master_bypass_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.master_bypass_get)
  return _internal_master_bypass_get();
}
inline ::fmsmoov::MasterBypassGetCommand* ProcessorCommand::unsafe_arena_release_master_bypass_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.master_bypass_get)
  if (_internal_has_master_bypass_get()) {
    clear_has_cmd_oneof();
    ::fmsmoov::MasterBypassGetCommand* temp = cmd_oneof_.master_bypass_get_;
    cmd_oneof_.master_bypass_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_master_bypass_get(::fmsmoov::MasterBypassGetCommand* master_bypass_get) {
  clear_cmd_oneof();
  if (master_bypass_get) {
    set_has_master_bypass_get();
    cmd_oneof_.master_bypass_get_ = master_bypass_get;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.master_bypass_get)
}
inline ::fmsmoov::MasterBypassGetCommand* ProcessorCommand::_internal_mutable_master_bypass_get() {
  if (!_internal_has_master_bypass_get()) {
    clear_cmd_oneof();
    set_has_master_bypass_get();
    cmd_oneof_.master_bypass_get_ = CreateMaybeMessage< ::fmsmoov::MasterBypassGetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.master_bypass_get_;
}
inline ::fmsmoov::MasterBypassGetCommand* ProcessorCommand::mutable_master_bypass_get() {
  ::fmsmoov::MasterBypassGetCommand* _msg = _internal_mutable_master_bypass_get();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.master_bypass_get)
  return _msg;
}

// .fmsmoov.GainSetCommand gain_set = 4;
inline bool ProcessorCommand::_internal_has_gain_set() const {
  return cmd_oneof_case() == kGainSet;
}
inline bool ProcessorCommand::has_gain_set() const {
  return _internal_has_gain_set();
}
inline void ProcessorCommand::set_has_gain_set() {
  _oneof_case_[0] = kGainSet;
}
inline void ProcessorCommand::clear_gain_set() {
  if (_internal_has_gain_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.gain_set_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::release_gain_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_cmd_oneof();
      ::fmsmoov::GainSetCommand* temp = cmd_oneof_.gain_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainSetCommand& ProcessorCommand::_internal_gain_set() const {
  return _internal_has_gain_set()
      ? *cmd_oneof_.gain_set_
      : reinterpret_cast< ::fmsmoov::GainSetCommand&>(::fmsmoov::_GainSetCommand_default_instance_);
}
inline const ::fmsmoov::GainSetCommand& ProcessorCommand::gain_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_set)
  return _internal_gain_set();
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::unsafe_arena_release_gain_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainSetCommand* temp = cmd_oneof_.gain_set_;
    cmd_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set) {
  clear_cmd_oneof();
  if (gain_set) {
    set_has_gain_set();
    cmd_oneof_.gain_set_ = gain_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.gain_set)
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::_internal_mutable_gain_set() {
  if (!_internal_has_gain_set()) {
    clear_cmd_oneof();
    set_has_gain_set();
    cmd_oneof_.gain_set_ = CreateMaybeMessage< ::fmsmoov::GainSetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.gain_set_;
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::mutable_gain_set() {
  ::fmsmoov::GainSetCommand* _msg = _internal_mutable_gain_set();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_set)
  return _msg;
}

// .fmsmoov.GainGetCommand gain_get = 5;
inline bool ProcessorCommand::_internal_has_gain_get() const {
  return cmd_oneof_case() == kGainGet;
}
inline bool ProcessorCommand::has_gain_get() const {
  return _internal_has_gain_get();
}
inline void ProcessorCommand::set_has_gain_get() {
  _oneof_case_[0] = kGainGet;
}
inline void ProcessorCommand::clear_gain_get() {
  if (_internal_has_gain_get()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.gain_get_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::release_gain_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_cmd_oneof();
      ::fmsmoov::GainGetCommand* temp = cmd_oneof_.gain_get_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainGetCommand& ProcessorCommand::_internal_gain_get() const {
  return _internal_has_gain_get()
      ? *cmd_oneof_.gain_get_
      : reinterpret_cast< ::fmsmoov::GainGetCommand&>(::fmsmoov::_GainGetCommand_default_instance_);
}
inline const ::fmsmoov::GainGetCommand& ProcessorCommand::gain_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_get)
  return _internal_gain_get();
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::unsafe_arena_release_gain_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainGetCommand* temp = cmd_oneof_.gain_get_;
    cmd_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get) {
  clear_cmd_oneof();
  if (gain_get) {
    set_has_gain_get();
    cmd_oneof_.gain_get_ = gain_get;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.gain_get)
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::_internal_mutable_gain_get() {
  if (!_internal_has_gain_get()) {
    clear_cmd_oneof();
    set_has_gain_get();
    cmd_oneof_.gain_get_ = CreateMaybeMessage< ::fmsmoov::GainGetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.gain_get_;
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::mutable_gain_get() {
  ::fmsmoov::GainGetCommand* _msg = _internal_mutable_gain_get();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_get)
  return _msg;
}

inline bool ProcessorCommand::has_cmd_oneof() const {
  return cmd_oneof_case() != CMD_ONEOF_NOT_SET;
}
inline void ProcessorCommand::clear_has_cmd_oneof() {
  _oneof_case_[0] = CMD_ONEOF_NOT_SET;
}
inline ProcessorCommand::CmdOneofCase ProcessorCommand::cmd_oneof_case() const {
  return ProcessorCommand::CmdOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorResponse

// .fmsmoov.ResponseCode response = 1;
inline void ProcessorResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode ProcessorResponse::_internal_response() const {
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline ::fmsmoov::ResponseCode ProcessorResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.response)
  return _internal_response();
}
inline void ProcessorResponse::_internal_set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
}
inline void ProcessorResponse::set_response(::fmsmoov::ResponseCode value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorResponse.response)
}

// string response_msg = 2;
inline void ProcessorResponse::clear_response_msg() {
  response_msg_.ClearToEmpty();
}
inline const std::string& ProcessorResponse::response_msg() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.response_msg)
  return _internal_response_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessorResponse::set_response_msg(ArgT0&& arg0, ArgT... args) {
 
 response_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorResponse.response_msg)
}
inline std::string* ProcessorResponse::mutable_response_msg() {
  std::string* _s = _internal_mutable_response_msg();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.response_msg)
  return _s;
}
inline const std::string& ProcessorResponse::_internal_response_msg() const {
  return response_msg_.Get();
}
inline void ProcessorResponse::_internal_set_response_msg(const std::string& value) {
  
  response_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcessorResponse::_internal_mutable_response_msg() {
  
  return response_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcessorResponse::release_response_msg() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.response_msg)
  return response_msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcessorResponse::set_allocated_response_msg(std::string* response_msg) {
  if (response_msg != nullptr) {
    
  } else {
    
  }
  response_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response_msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.response_msg)
}

// optional .fmsmoov.MasterBypassSetResponse master_bypass_set_rsp = 3;
inline bool ProcessorResponse::_internal_has_master_bypass_set_rsp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || master_bypass_set_rsp_ != nullptr);
  return value;
}
inline bool ProcessorResponse::has_master_bypass_set_rsp() const {
  return _internal_has_master_bypass_set_rsp();
}
inline void ProcessorResponse::clear_master_bypass_set_rsp() {
  if (master_bypass_set_rsp_ != nullptr) master_bypass_set_rsp_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::fmsmoov::MasterBypassSetResponse& ProcessorResponse::_internal_master_bypass_set_rsp() const {
  const ::fmsmoov::MasterBypassSetResponse* p = master_bypass_set_rsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::fmsmoov::MasterBypassSetResponse&>(
      ::fmsmoov::_MasterBypassSetResponse_default_instance_);
}
inline const ::fmsmoov::MasterBypassSetResponse& ProcessorResponse::master_bypass_set_rsp() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.master_bypass_set_rsp)
  return _internal_master_bypass_set_rsp();
}
inline void ProcessorResponse::unsafe_arena_set_allocated_master_bypass_set_rsp(
    ::fmsmoov::MasterBypassSetResponse* master_bypass_set_rsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_bypass_set_rsp_);
  }
  master_bypass_set_rsp_ = master_bypass_set_rsp;
  if (master_bypass_set_rsp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.master_bypass_set_rsp)
}
inline ::fmsmoov::MasterBypassSetResponse* ProcessorResponse::release_master_bypass_set_rsp() {
  _has_bits_[0] &= ~0x00000001u;
  ::fmsmoov::MasterBypassSetResponse* temp = master_bypass_set_rsp_;
  master_bypass_set_rsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fmsmoov::MasterBypassSetResponse* ProcessorResponse::unsafe_arena_release_master_bypass_set_rsp() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.master_bypass_set_rsp)
  _has_bits_[0] &= ~0x00000001u;
  ::fmsmoov::MasterBypassSetResponse* temp = master_bypass_set_rsp_;
  master_bypass_set_rsp_ = nullptr;
  return temp;
}
inline ::fmsmoov::MasterBypassSetResponse* ProcessorResponse::_internal_mutable_master_bypass_set_rsp() {
  _has_bits_[0] |= 0x00000001u;
  if (master_bypass_set_rsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fmsmoov::MasterBypassSetResponse>(GetArenaForAllocation());
    master_bypass_set_rsp_ = p;
  }
  return master_bypass_set_rsp_;
}
inline ::fmsmoov::MasterBypassSetResponse* ProcessorResponse::mutable_master_bypass_set_rsp() {
  ::fmsmoov::MasterBypassSetResponse* _msg = _internal_mutable_master_bypass_set_rsp();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.master_bypass_set_rsp)
  return _msg;
}
inline void ProcessorResponse::set_allocated_master_bypass_set_rsp(::fmsmoov::MasterBypassSetResponse* master_bypass_set_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete master_bypass_set_rsp_;
  }
  if (master_bypass_set_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fmsmoov::MasterBypassSetResponse>::GetOwningArena(master_bypass_set_rsp);
    if (message_arena != submessage_arena) {
      master_bypass_set_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master_bypass_set_rsp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  master_bypass_set_rsp_ = master_bypass_set_rsp;
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.master_bypass_set_rsp)
}

// optional .fmsmoov.MasterBypassGetResponse master_bypass_get_rsp = 4;
inline bool ProcessorResponse::_internal_has_master_bypass_get_rsp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || master_bypass_get_rsp_ != nullptr);
  return value;
}
inline bool ProcessorResponse::has_master_bypass_get_rsp() const {
  return _internal_has_master_bypass_get_rsp();
}
inline void ProcessorResponse::clear_master_bypass_get_rsp() {
  if (master_bypass_get_rsp_ != nullptr) master_bypass_get_rsp_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fmsmoov::MasterBypassGetResponse& ProcessorResponse::_internal_master_bypass_get_rsp() const {
  const ::fmsmoov::MasterBypassGetResponse* p = master_bypass_get_rsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::fmsmoov::MasterBypassGetResponse&>(
      ::fmsmoov::_MasterBypassGetResponse_default_instance_);
}
inline const ::fmsmoov::MasterBypassGetResponse& ProcessorResponse::master_bypass_get_rsp() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.master_bypass_get_rsp)
  return _internal_master_bypass_get_rsp();
}
inline void ProcessorResponse::unsafe_arena_set_allocated_master_bypass_get_rsp(
    ::fmsmoov::MasterBypassGetResponse* master_bypass_get_rsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_bypass_get_rsp_);
  }
  master_bypass_get_rsp_ = master_bypass_get_rsp;
  if (master_bypass_get_rsp) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.master_bypass_get_rsp)
}
inline ::fmsmoov::MasterBypassGetResponse* ProcessorResponse::release_master_bypass_get_rsp() {
  _has_bits_[0] &= ~0x00000002u;
  ::fmsmoov::MasterBypassGetResponse* temp = master_bypass_get_rsp_;
  master_bypass_get_rsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fmsmoov::MasterBypassGetResponse* ProcessorResponse::unsafe_arena_release_master_bypass_get_rsp() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.master_bypass_get_rsp)
  _has_bits_[0] &= ~0x00000002u;
  ::fmsmoov::MasterBypassGetResponse* temp = master_bypass_get_rsp_;
  master_bypass_get_rsp_ = nullptr;
  return temp;
}
inline ::fmsmoov::MasterBypassGetResponse* ProcessorResponse::_internal_mutable_master_bypass_get_rsp() {
  _has_bits_[0] |= 0x00000002u;
  if (master_bypass_get_rsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fmsmoov::MasterBypassGetResponse>(GetArenaForAllocation());
    master_bypass_get_rsp_ = p;
  }
  return master_bypass_get_rsp_;
}
inline ::fmsmoov::MasterBypassGetResponse* ProcessorResponse::mutable_master_bypass_get_rsp() {
  ::fmsmoov::MasterBypassGetResponse* _msg = _internal_mutable_master_bypass_get_rsp();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.master_bypass_get_rsp)
  return _msg;
}
inline void ProcessorResponse::set_allocated_master_bypass_get_rsp(::fmsmoov::MasterBypassGetResponse* master_bypass_get_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete master_bypass_get_rsp_;
  }
  if (master_bypass_get_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fmsmoov::MasterBypassGetResponse>::GetOwningArena(master_bypass_get_rsp);
    if (message_arena != submessage_arena) {
      master_bypass_get_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master_bypass_get_rsp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  master_bypass_get_rsp_ = master_bypass_get_rsp;
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.master_bypass_get_rsp)
}

// optional .fmsmoov.GainGetResponse gain_get_rsp = 5;
inline bool ProcessorResponse::_internal_has_gain_get_rsp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gain_get_rsp_ != nullptr);
  return value;
}
inline bool ProcessorResponse::has_gain_get_rsp() const {
  return _internal_has_gain_get_rsp();
}
inline void ProcessorResponse::clear_gain_get_rsp() {
  if (gain_get_rsp_ != nullptr) gain_get_rsp_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fmsmoov::GainGetResponse& ProcessorResponse::_internal_gain_get_rsp() const {
  const ::fmsmoov::GainGetResponse* p = gain_get_rsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::fmsmoov::GainGetResponse&>(
      ::fmsmoov::_GainGetResponse_default_instance_);
}
inline const ::fmsmoov::GainGetResponse& ProcessorResponse::gain_get_rsp() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.gain_get_rsp)
  return _internal_gain_get_rsp();
}
inline void ProcessorResponse::unsafe_arena_set_allocated_gain_get_rsp(
    ::fmsmoov::GainGetResponse* gain_get_rsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gain_get_rsp_);
  }
  gain_get_rsp_ = gain_get_rsp;
  if (gain_get_rsp) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.gain_get_rsp)
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::release_gain_get_rsp() {
  _has_bits_[0] &= ~0x00000004u;
  ::fmsmoov::GainGetResponse* temp = gain_get_rsp_;
  gain_get_rsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::unsafe_arena_release_gain_get_rsp() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.gain_get_rsp)
  _has_bits_[0] &= ~0x00000004u;
  ::fmsmoov::GainGetResponse* temp = gain_get_rsp_;
  gain_get_rsp_ = nullptr;
  return temp;
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::_internal_mutable_gain_get_rsp() {
  _has_bits_[0] |= 0x00000004u;
  if (gain_get_rsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fmsmoov::GainGetResponse>(GetArenaForAllocation());
    gain_get_rsp_ = p;
  }
  return gain_get_rsp_;
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::mutable_gain_get_rsp() {
  ::fmsmoov::GainGetResponse* _msg = _internal_mutable_gain_get_rsp();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.gain_get_rsp)
  return _msg;
}
inline void ProcessorResponse::set_allocated_gain_get_rsp(::fmsmoov::GainGetResponse* gain_get_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gain_get_rsp_;
  }
  if (gain_get_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fmsmoov::GainGetResponse>::GetOwningArena(gain_get_rsp);
    if (message_arena != submessage_arena) {
      gain_get_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gain_get_rsp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gain_get_rsp_ = gain_get_rsp;
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.gain_get_rsp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fmsmoov

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fmsmoov::GainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::GainType>() {
  return ::fmsmoov::GainType_descriptor();
}
template <> struct is_proto_enum< ::fmsmoov::ResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::ResponseCode>() {
  return ::fmsmoov::ResponseCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto
