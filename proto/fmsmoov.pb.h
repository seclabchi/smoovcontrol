// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fmsmoov.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fmsmoov_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fmsmoov_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fmsmoov_2eproto;
namespace fmsmoov {
class GainGetCommand;
struct GainGetCommandDefaultTypeInternal;
extern GainGetCommandDefaultTypeInternal _GainGetCommand_default_instance_;
class GainGetResponse;
struct GainGetResponseDefaultTypeInternal;
extern GainGetResponseDefaultTypeInternal _GainGetResponse_default_instance_;
class GainPair;
struct GainPairDefaultTypeInternal;
extern GainPairDefaultTypeInternal _GainPair_default_instance_;
class GainSetCommand;
struct GainSetCommandDefaultTypeInternal;
extern GainSetCommandDefaultTypeInternal _GainSetCommand_default_instance_;
class GainSetResponse;
struct GainSetResponseDefaultTypeInternal;
extern GainSetResponseDefaultTypeInternal _GainSetResponse_default_instance_;
class ProcessorCommand;
struct ProcessorCommandDefaultTypeInternal;
extern ProcessorCommandDefaultTypeInternal _ProcessorCommand_default_instance_;
class ProcessorLiveData;
struct ProcessorLiveDataDefaultTypeInternal;
extern ProcessorLiveDataDefaultTypeInternal _ProcessorLiveData_default_instance_;
class ProcessorResponse;
struct ProcessorResponseDefaultTypeInternal;
extern ProcessorResponseDefaultTypeInternal _ProcessorResponse_default_instance_;
class ShutdownCommand;
struct ShutdownCommandDefaultTypeInternal;
extern ShutdownCommandDefaultTypeInternal _ShutdownCommand_default_instance_;
class ShutdownResponse;
struct ShutdownResponseDefaultTypeInternal;
extern ShutdownResponseDefaultTypeInternal _ShutdownResponse_default_instance_;
}  // namespace fmsmoov
PROTOBUF_NAMESPACE_OPEN
template<> ::fmsmoov::GainGetCommand* Arena::CreateMaybeMessage<::fmsmoov::GainGetCommand>(Arena*);
template<> ::fmsmoov::GainGetResponse* Arena::CreateMaybeMessage<::fmsmoov::GainGetResponse>(Arena*);
template<> ::fmsmoov::GainPair* Arena::CreateMaybeMessage<::fmsmoov::GainPair>(Arena*);
template<> ::fmsmoov::GainSetCommand* Arena::CreateMaybeMessage<::fmsmoov::GainSetCommand>(Arena*);
template<> ::fmsmoov::GainSetResponse* Arena::CreateMaybeMessage<::fmsmoov::GainSetResponse>(Arena*);
template<> ::fmsmoov::ProcessorCommand* Arena::CreateMaybeMessage<::fmsmoov::ProcessorCommand>(Arena*);
template<> ::fmsmoov::ProcessorLiveData* Arena::CreateMaybeMessage<::fmsmoov::ProcessorLiveData>(Arena*);
template<> ::fmsmoov::ProcessorResponse* Arena::CreateMaybeMessage<::fmsmoov::ProcessorResponse>(Arena*);
template<> ::fmsmoov::ShutdownCommand* Arena::CreateMaybeMessage<::fmsmoov::ShutdownCommand>(Arena*);
template<> ::fmsmoov::ShutdownResponse* Arena::CreateMaybeMessage<::fmsmoov::ShutdownResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fmsmoov {

enum GainType : int {
  LINEAR = 0,
  LOG = 1,
  GainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GainType_IsValid(int value);
constexpr GainType GainType_MIN = LINEAR;
constexpr GainType GainType_MAX = LOG;
constexpr int GainType_ARRAYSIZE = GainType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GainType_descriptor();
template<typename T>
inline const std::string& GainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GainType_descriptor(), enum_t_value);
}
inline bool GainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GainType>(
    GainType_descriptor(), name, value);
}
enum ResponseCode : int {
  OK = 0,
  ERROR = 1,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = OK;
constexpr ResponseCode ResponseCode_MAX = ERROR;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor();
template<typename T>
inline const std::string& ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCode_descriptor(), enum_t_value);
}
inline bool ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
// ===================================================================

class GainPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainPair) */ {
 public:
  inline GainPair() : GainPair(nullptr) {}
  ~GainPair() override;
  explicit constexpr GainPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainPair(const GainPair& from);
  GainPair(GainPair&& from) noexcept
    : GainPair() {
    *this = ::std::move(from);
  }

  inline GainPair& operator=(const GainPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainPair& operator=(GainPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const GainPair* internal_default_instance() {
    return reinterpret_cast<const GainPair*>(
               &_GainPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GainPair& a, GainPair& b) {
    a.Swap(&b);
  }
  inline void Swap(GainPair* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainPair* New() const final {
    return new GainPair();
  }

  GainPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainPair";
  }
  protected:
  explicit GainPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLFieldNumber = 1,
    kRFieldNumber = 2,
  };
  // float l = 1;
  void clear_l();
  float l() const;
  void set_l(float value);
  private:
  float _internal_l() const;
  void _internal_set_l(float value);
  public:

  // float r = 2;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.GainPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float l_;
  float r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorLiveData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorLiveData) */ {
 public:
  inline ProcessorLiveData() : ProcessorLiveData(nullptr) {}
  ~ProcessorLiveData() override;
  explicit constexpr ProcessorLiveData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorLiveData(const ProcessorLiveData& from);
  ProcessorLiveData(ProcessorLiveData&& from) noexcept
    : ProcessorLiveData() {
    *this = ::std::move(from);
  }

  inline ProcessorLiveData& operator=(const ProcessorLiveData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorLiveData& operator=(ProcessorLiveData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorLiveData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessorLiveData* internal_default_instance() {
    return reinterpret_cast<const ProcessorLiveData*>(
               &_ProcessorLiveData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProcessorLiveData& a, ProcessorLiveData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorLiveData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorLiveData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorLiveData* New() const final {
    return new ProcessorLiveData();
  }

  ProcessorLiveData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorLiveData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorLiveData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorLiveData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorLiveData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorLiveData";
  }
  protected:
  explicit ProcessorLiveData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInLFieldNumber = 1,
    kInRFieldNumber = 2,
    kOutLFieldNumber = 3,
    kOutRFieldNumber = 4,
  };
  // optional float inL = 1;
  bool has_inl() const;
  private:
  bool _internal_has_inl() const;
  public:
  void clear_inl();
  float inl() const;
  void set_inl(float value);
  private:
  float _internal_inl() const;
  void _internal_set_inl(float value);
  public:

  // optional float inR = 2;
  bool has_inr() const;
  private:
  bool _internal_has_inr() const;
  public:
  void clear_inr();
  float inr() const;
  void set_inr(float value);
  private:
  float _internal_inr() const;
  void _internal_set_inr(float value);
  public:

  // optional float outL = 3;
  bool has_outl() const;
  private:
  bool _internal_has_outl() const;
  public:
  void clear_outl();
  float outl() const;
  void set_outl(float value);
  private:
  float _internal_outl() const;
  void _internal_set_outl(float value);
  public:

  // optional float outR = 4;
  bool has_outr() const;
  private:
  bool _internal_has_outr() const;
  public:
  void clear_outr();
  float outr() const;
  void set_outr(float value);
  private:
  float _internal_outr() const;
  void _internal_set_outr(float value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorLiveData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float inl_;
  float inr_;
  float outl_;
  float outr_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ShutdownCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ShutdownCommand) */ {
 public:
  inline ShutdownCommand() : ShutdownCommand(nullptr) {}
  ~ShutdownCommand() override;
  explicit constexpr ShutdownCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownCommand(const ShutdownCommand& from);
  ShutdownCommand(ShutdownCommand&& from) noexcept
    : ShutdownCommand() {
    *this = ::std::move(from);
  }

  inline ShutdownCommand& operator=(const ShutdownCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownCommand& operator=(ShutdownCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownCommand* internal_default_instance() {
    return reinterpret_cast<const ShutdownCommand*>(
               &_ShutdownCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ShutdownCommand& a, ShutdownCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownCommand* New() const final {
    return new ShutdownCommand();
  }

  ShutdownCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShutdownCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ShutdownCommand";
  }
  protected:
  explicit ShutdownCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_MUST_USE_RESULT std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.ShutdownCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ShutdownResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ShutdownResponse) */ {
 public:
  inline ShutdownResponse() : ShutdownResponse(nullptr) {}
  ~ShutdownResponse() override;
  explicit constexpr ShutdownResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownResponse(const ShutdownResponse& from);
  ShutdownResponse(ShutdownResponse&& from) noexcept
    : ShutdownResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownResponse& operator=(const ShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownResponse& operator=(ShutdownResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownResponse*>(
               &_ShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ShutdownResponse& a, ShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownResponse* New() const final {
    return new ShutdownResponse();
  }

  ShutdownResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShutdownResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ShutdownResponse";
  }
  protected:
  explicit ShutdownResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);
  private:
  ::fmsmoov::ResponseCode _internal_response() const;
  void _internal_set_response(::fmsmoov::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.ShutdownResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainSetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainSetCommand) */ {
 public:
  inline GainSetCommand() : GainSetCommand(nullptr) {}
  ~GainSetCommand() override;
  explicit constexpr GainSetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainSetCommand(const GainSetCommand& from);
  GainSetCommand(GainSetCommand&& from) noexcept
    : GainSetCommand() {
    *this = ::std::move(from);
  }

  inline GainSetCommand& operator=(const GainSetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainSetCommand& operator=(GainSetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainSetCommand& default_instance() {
    return *internal_default_instance();
  }
  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainSetCommand* internal_default_instance() {
    return reinterpret_cast<const GainSetCommand*>(
               &_GainSetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GainSetCommand& a, GainSetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GainSetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainSetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainSetCommand* New() const final {
    return new GainSetCommand();
  }

  GainSetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainSetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainSetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainSetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainSetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainSetCommand";
  }
  protected:
  explicit GainSetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
    kTypeFieldNumber = 4,
    kGainPairFieldNumber = 2,
    kGainFieldNumber = 3,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // .fmsmoov.GainType type = 4;
  void clear_type();
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);
  private:
  ::fmsmoov::GainType _internal_type() const;
  void _internal_set_type(::fmsmoov::GainType value);
  public:

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  private:
  bool _internal_has_gain_pair() const;
  public:
  void clear_gain_pair();
  const ::fmsmoov::GainPair& gain_pair() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainPair* release_gain_pair();
  ::fmsmoov::GainPair* mutable_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);
  private:
  const ::fmsmoov::GainPair& _internal_gain_pair() const;
  ::fmsmoov::GainPair* _internal_mutable_gain_pair();
  public:
  void unsafe_arena_set_allocated_gain_pair(
      ::fmsmoov::GainPair* gain_pair);
  ::fmsmoov::GainPair* unsafe_arena_release_gain_pair();

  // float gain = 3;
  bool has_gain() const;
  private:
  bool _internal_has_gain() const;
  public:
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  void clear_gaintype_oneof();
  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainSetCommand)
 private:
  class _Internal;
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  inline void clear_has_gaintype_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    constexpr GaintypeOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainSetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainSetResponse) */ {
 public:
  inline GainSetResponse() : GainSetResponse(nullptr) {}
  ~GainSetResponse() override;
  explicit constexpr GainSetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainSetResponse(const GainSetResponse& from);
  GainSetResponse(GainSetResponse&& from) noexcept
    : GainSetResponse() {
    *this = ::std::move(from);
  }

  inline GainSetResponse& operator=(const GainSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainSetResponse& operator=(GainSetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainSetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GainSetResponse* internal_default_instance() {
    return reinterpret_cast<const GainSetResponse*>(
               &_GainSetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GainSetResponse& a, GainSetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GainSetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainSetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainSetResponse* New() const final {
    return new GainSetResponse();
  }

  GainSetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainSetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainSetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainSetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainSetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainSetResponse";
  }
  protected:
  explicit GainSetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);
  private:
  ::fmsmoov::ResponseCode _internal_response() const;
  void _internal_set_response(::fmsmoov::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.GainSetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainGetCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetCommand) */ {
 public:
  inline GainGetCommand() : GainGetCommand(nullptr) {}
  ~GainGetCommand() override;
  explicit constexpr GainGetCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainGetCommand(const GainGetCommand& from);
  GainGetCommand(GainGetCommand&& from) noexcept
    : GainGetCommand() {
    *this = ::std::move(from);
  }

  inline GainGetCommand& operator=(const GainGetCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainGetCommand& operator=(GainGetCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainGetCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const GainGetCommand* internal_default_instance() {
    return reinterpret_cast<const GainGetCommand*>(
               &_GainGetCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GainGetCommand& a, GainGetCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GainGetCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainGetCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainGetCommand* New() const final {
    return new GainGetCommand();
  }

  GainGetCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainGetCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainGetCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainGetCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainGetCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainGetCommand";
  }
  protected:
  explicit GainGetCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class GainGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetResponse) */ {
 public:
  inline GainGetResponse() : GainGetResponse(nullptr) {}
  ~GainGetResponse() override;
  explicit constexpr GainGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GainGetResponse(const GainGetResponse& from);
  GainGetResponse(GainGetResponse&& from) noexcept
    : GainGetResponse() {
    *this = ::std::move(from);
  }

  inline GainGetResponse& operator=(const GainGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainGetResponse& operator=(GainGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GainGetResponse& default_instance() {
    return *internal_default_instance();
  }
  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainGetResponse* internal_default_instance() {
    return reinterpret_cast<const GainGetResponse*>(
               &_GainGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GainGetResponse& a, GainGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GainGetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainGetResponse* New() const final {
    return new GainGetResponse();
  }

  GainGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GainGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GainGetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainGetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.GainGetResponse";
  }
  protected:
  explicit GainGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhichFieldNumber = 1,
    kTypeFieldNumber = 4,
    kGainPairFieldNumber = 2,
    kGainFieldNumber = 3,
  };
  // string which = 1;
  void clear_which();
  const std::string& which() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_which(ArgT0&& arg0, ArgT... args);
  std::string* mutable_which();
  PROTOBUF_MUST_USE_RESULT std::string* release_which();
  void set_allocated_which(std::string* which);
  private:
  const std::string& _internal_which() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_which(const std::string& value);
  std::string* _internal_mutable_which();
  public:

  // .fmsmoov.GainType type = 4;
  void clear_type();
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);
  private:
  ::fmsmoov::GainType _internal_type() const;
  void _internal_set_type(::fmsmoov::GainType value);
  public:

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  private:
  bool _internal_has_gain_pair() const;
  public:
  void clear_gain_pair();
  const ::fmsmoov::GainPair& gain_pair() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainPair* release_gain_pair();
  ::fmsmoov::GainPair* mutable_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);
  private:
  const ::fmsmoov::GainPair& _internal_gain_pair() const;
  ::fmsmoov::GainPair* _internal_mutable_gain_pair();
  public:
  void unsafe_arena_set_allocated_gain_pair(
      ::fmsmoov::GainPair* gain_pair);
  ::fmsmoov::GainPair* unsafe_arena_release_gain_pair();

  // float gain = 3;
  bool has_gain() const;
  private:
  bool _internal_has_gain() const;
  public:
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  void clear_gaintype_oneof();
  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetResponse)
 private:
  class _Internal;
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  inline void clear_has_gaintype_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    constexpr GaintypeOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorCommand) */ {
 public:
  inline ProcessorCommand() : ProcessorCommand(nullptr) {}
  ~ProcessorCommand() override;
  explicit constexpr ProcessorCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorCommand(const ProcessorCommand& from);
  ProcessorCommand(ProcessorCommand&& from) noexcept
    : ProcessorCommand() {
    *this = ::std::move(from);
  }

  inline ProcessorCommand& operator=(const ProcessorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorCommand& operator=(ProcessorCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CmdOneofCase {
    kShutdown = 1,
    kGainSet = 2,
    kGainGet = 3,
    CMD_ONEOF_NOT_SET = 0,
  };

  static inline const ProcessorCommand* internal_default_instance() {
    return reinterpret_cast<const ProcessorCommand*>(
               &_ProcessorCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProcessorCommand& a, ProcessorCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorCommand* New() const final {
    return new ProcessorCommand();
  }

  ProcessorCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorCommand";
  }
  protected:
  explicit ProcessorCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShutdownFieldNumber = 1,
    kGainSetFieldNumber = 2,
    kGainGetFieldNumber = 3,
  };
  // .fmsmoov.ShutdownCommand shutdown = 1;
  bool has_shutdown() const;
  private:
  bool _internal_has_shutdown() const;
  public:
  void clear_shutdown();
  const ::fmsmoov::ShutdownCommand& shutdown() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::ShutdownCommand* release_shutdown();
  ::fmsmoov::ShutdownCommand* mutable_shutdown();
  void set_allocated_shutdown(::fmsmoov::ShutdownCommand* shutdown);
  private:
  const ::fmsmoov::ShutdownCommand& _internal_shutdown() const;
  ::fmsmoov::ShutdownCommand* _internal_mutable_shutdown();
  public:
  void unsafe_arena_set_allocated_shutdown(
      ::fmsmoov::ShutdownCommand* shutdown);
  ::fmsmoov::ShutdownCommand* unsafe_arena_release_shutdown();

  // .fmsmoov.GainSetCommand gain_set = 2;
  bool has_gain_set() const;
  private:
  bool _internal_has_gain_set() const;
  public:
  void clear_gain_set();
  const ::fmsmoov::GainSetCommand& gain_set() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainSetCommand* release_gain_set();
  ::fmsmoov::GainSetCommand* mutable_gain_set();
  void set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set);
  private:
  const ::fmsmoov::GainSetCommand& _internal_gain_set() const;
  ::fmsmoov::GainSetCommand* _internal_mutable_gain_set();
  public:
  void unsafe_arena_set_allocated_gain_set(
      ::fmsmoov::GainSetCommand* gain_set);
  ::fmsmoov::GainSetCommand* unsafe_arena_release_gain_set();

  // .fmsmoov.GainGetCommand gain_get = 3;
  bool has_gain_get() const;
  private:
  bool _internal_has_gain_get() const;
  public:
  void clear_gain_get();
  const ::fmsmoov::GainGetCommand& gain_get() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainGetCommand* release_gain_get();
  ::fmsmoov::GainGetCommand* mutable_gain_get();
  void set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get);
  private:
  const ::fmsmoov::GainGetCommand& _internal_gain_get() const;
  ::fmsmoov::GainGetCommand* _internal_mutable_gain_get();
  public:
  void unsafe_arena_set_allocated_gain_get(
      ::fmsmoov::GainGetCommand* gain_get);
  ::fmsmoov::GainGetCommand* unsafe_arena_release_gain_get();

  void clear_cmd_oneof();
  CmdOneofCase cmd_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorCommand)
 private:
  class _Internal;
  void set_has_shutdown();
  void set_has_gain_set();
  void set_has_gain_get();

  inline bool has_cmd_oneof() const;
  inline void clear_has_cmd_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CmdOneofUnion {
    constexpr CmdOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::ShutdownCommand* shutdown_;
    ::fmsmoov::GainSetCommand* gain_set_;
    ::fmsmoov::GainGetCommand* gain_get_;
  } cmd_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// -------------------------------------------------------------------

class ProcessorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorResponse) */ {
 public:
  inline ProcessorResponse() : ProcessorResponse(nullptr) {}
  ~ProcessorResponse() override;
  explicit constexpr ProcessorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorResponse(const ProcessorResponse& from);
  ProcessorResponse(ProcessorResponse&& from) noexcept
    : ProcessorResponse() {
    *this = ::std::move(from);
  }

  inline ProcessorResponse& operator=(const ProcessorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorResponse& operator=(ProcessorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorResponse& default_instance() {
    return *internal_default_instance();
  }
  enum RspOneofCase {
    kShutdown = 3,
    kGainSet = 4,
    kGainGet = 5,
    RSP_ONEOF_NOT_SET = 0,
  };

  static inline const ProcessorResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessorResponse*>(
               &_ProcessorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProcessorResponse& a, ProcessorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorResponse* New() const final {
    return new ProcessorResponse();
  }

  ProcessorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fmsmoov.ProcessorResponse";
  }
  protected:
  explicit ProcessorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseMsgFieldNumber = 2,
    kResponseFieldNumber = 1,
    kShutdownFieldNumber = 3,
    kGainSetFieldNumber = 4,
    kGainGetFieldNumber = 5,
  };
  // string response_msg = 2;
  void clear_response_msg();
  const std::string& response_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_response_msg();
  void set_allocated_response_msg(std::string* response_msg);
  private:
  const std::string& _internal_response_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_msg(const std::string& value);
  std::string* _internal_mutable_response_msg();
  public:

  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);
  private:
  ::fmsmoov::ResponseCode _internal_response() const;
  void _internal_set_response(::fmsmoov::ResponseCode value);
  public:

  // .fmsmoov.ShutdownResponse shutdown = 3;
  bool has_shutdown() const;
  private:
  bool _internal_has_shutdown() const;
  public:
  void clear_shutdown();
  const ::fmsmoov::ShutdownResponse& shutdown() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::ShutdownResponse* release_shutdown();
  ::fmsmoov::ShutdownResponse* mutable_shutdown();
  void set_allocated_shutdown(::fmsmoov::ShutdownResponse* shutdown);
  private:
  const ::fmsmoov::ShutdownResponse& _internal_shutdown() const;
  ::fmsmoov::ShutdownResponse* _internal_mutable_shutdown();
  public:
  void unsafe_arena_set_allocated_shutdown(
      ::fmsmoov::ShutdownResponse* shutdown);
  ::fmsmoov::ShutdownResponse* unsafe_arena_release_shutdown();

  // .fmsmoov.GainSetResponse gain_set = 4;
  bool has_gain_set() const;
  private:
  bool _internal_has_gain_set() const;
  public:
  void clear_gain_set();
  const ::fmsmoov::GainSetResponse& gain_set() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainSetResponse* release_gain_set();
  ::fmsmoov::GainSetResponse* mutable_gain_set();
  void set_allocated_gain_set(::fmsmoov::GainSetResponse* gain_set);
  private:
  const ::fmsmoov::GainSetResponse& _internal_gain_set() const;
  ::fmsmoov::GainSetResponse* _internal_mutable_gain_set();
  public:
  void unsafe_arena_set_allocated_gain_set(
      ::fmsmoov::GainSetResponse* gain_set);
  ::fmsmoov::GainSetResponse* unsafe_arena_release_gain_set();

  // .fmsmoov.GainGetResponse gain_get = 5;
  bool has_gain_get() const;
  private:
  bool _internal_has_gain_get() const;
  public:
  void clear_gain_get();
  const ::fmsmoov::GainGetResponse& gain_get() const;
  PROTOBUF_MUST_USE_RESULT ::fmsmoov::GainGetResponse* release_gain_get();
  ::fmsmoov::GainGetResponse* mutable_gain_get();
  void set_allocated_gain_get(::fmsmoov::GainGetResponse* gain_get);
  private:
  const ::fmsmoov::GainGetResponse& _internal_gain_get() const;
  ::fmsmoov::GainGetResponse* _internal_mutable_gain_get();
  public:
  void unsafe_arena_set_allocated_gain_get(
      ::fmsmoov::GainGetResponse* gain_get);
  ::fmsmoov::GainGetResponse* unsafe_arena_release_gain_get();

  void clear_rsp_oneof();
  RspOneofCase rsp_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorResponse)
 private:
  class _Internal;
  void set_has_shutdown();
  void set_has_gain_set();
  void set_has_gain_get();

  inline bool has_rsp_oneof() const;
  inline void clear_has_rsp_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_msg_;
  int response_;
  union RspOneofUnion {
    constexpr RspOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::fmsmoov::ShutdownResponse* shutdown_;
    ::fmsmoov::GainSetResponse* gain_set_;
    ::fmsmoov::GainGetResponse* gain_get_;
  } rsp_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fmsmoov_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GainPair

// float l = 1;
inline void GainPair::clear_l() {
  l_ = 0;
}
inline float GainPair::_internal_l() const {
  return l_;
}
inline float GainPair::l() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.l)
  return _internal_l();
}
inline void GainPair::_internal_set_l(float value) {
  
  l_ = value;
}
inline void GainPair::set_l(float value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.l)
}

// float r = 2;
inline void GainPair::clear_r() {
  r_ = 0;
}
inline float GainPair::_internal_r() const {
  return r_;
}
inline float GainPair::r() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.r)
  return _internal_r();
}
inline void GainPair::_internal_set_r(float value) {
  
  r_ = value;
}
inline void GainPair::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.r)
}

// -------------------------------------------------------------------

// ProcessorLiveData

// optional float inL = 1;
inline bool ProcessorLiveData::_internal_has_inl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_inl() const {
  return _internal_has_inl();
}
inline void ProcessorLiveData::clear_inl() {
  inl_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ProcessorLiveData::_internal_inl() const {
  return inl_;
}
inline float ProcessorLiveData::inl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inL)
  return _internal_inl();
}
inline void ProcessorLiveData::_internal_set_inl(float value) {
  _has_bits_[0] |= 0x00000001u;
  inl_ = value;
}
inline void ProcessorLiveData::set_inl(float value) {
  _internal_set_inl(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inL)
}

// optional float inR = 2;
inline bool ProcessorLiveData::_internal_has_inr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_inr() const {
  return _internal_has_inr();
}
inline void ProcessorLiveData::clear_inr() {
  inr_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ProcessorLiveData::_internal_inr() const {
  return inr_;
}
inline float ProcessorLiveData::inr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inR)
  return _internal_inr();
}
inline void ProcessorLiveData::_internal_set_inr(float value) {
  _has_bits_[0] |= 0x00000002u;
  inr_ = value;
}
inline void ProcessorLiveData::set_inr(float value) {
  _internal_set_inr(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inR)
}

// optional float outL = 3;
inline bool ProcessorLiveData::_internal_has_outl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_outl() const {
  return _internal_has_outl();
}
inline void ProcessorLiveData::clear_outl() {
  outl_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ProcessorLiveData::_internal_outl() const {
  return outl_;
}
inline float ProcessorLiveData::outl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outL)
  return _internal_outl();
}
inline void ProcessorLiveData::_internal_set_outl(float value) {
  _has_bits_[0] |= 0x00000004u;
  outl_ = value;
}
inline void ProcessorLiveData::set_outl(float value) {
  _internal_set_outl(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outL)
}

// optional float outR = 4;
inline bool ProcessorLiveData::_internal_has_outr() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProcessorLiveData::has_outr() const {
  return _internal_has_outr();
}
inline void ProcessorLiveData::clear_outr() {
  outr_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ProcessorLiveData::_internal_outr() const {
  return outr_;
}
inline float ProcessorLiveData::outr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outR)
  return _internal_outr();
}
inline void ProcessorLiveData::_internal_set_outr(float value) {
  _has_bits_[0] |= 0x00000008u;
  outr_ = value;
}
inline void ProcessorLiveData::set_outr(float value) {
  _internal_set_outr(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outR)
}

// -------------------------------------------------------------------

// ShutdownCommand

// string reason = 1;
inline void ShutdownCommand::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& ShutdownCommand::reason() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ShutdownCommand.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShutdownCommand::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.ShutdownCommand.reason)
}
inline std::string* ShutdownCommand::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ShutdownCommand.reason)
  return _s;
}
inline const std::string& ShutdownCommand::_internal_reason() const {
  return reason_.Get();
}
inline void ShutdownCommand::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShutdownCommand::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShutdownCommand::release_reason() {
  // @@protoc_insertion_point(field_release:fmsmoov.ShutdownCommand.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShutdownCommand::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ShutdownCommand.reason)
}

// -------------------------------------------------------------------

// ShutdownResponse

// .fmsmoov.ResponseCode response = 1;
inline void ShutdownResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode ShutdownResponse::_internal_response() const {
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline ::fmsmoov::ResponseCode ShutdownResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ShutdownResponse.response)
  return _internal_response();
}
inline void ShutdownResponse::_internal_set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
}
inline void ShutdownResponse::set_response(::fmsmoov::ResponseCode value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ShutdownResponse.response)
}

// -------------------------------------------------------------------

// GainSetCommand

// string which = 1;
inline void GainSetCommand::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainSetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainSetCommand::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.which)
}
inline std::string* GainSetCommand::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.which)
  return _s;
}
inline const std::string& GainSetCommand::_internal_which() const {
  return which_.Get();
}
inline void GainSetCommand::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainSetCommand::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainSetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainSetCommand::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainSetCommand.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainSetCommand::_internal_has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline bool GainSetCommand::has_gain_pair() const {
  return _internal_has_gain_pair();
}
inline void GainSetCommand::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainSetCommand::clear_gain_pair() {
  if (_internal_has_gain_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete gaintype_oneof_.gain_pair_;
    }
    clear_has_gaintype_oneof();
  }
}
inline ::fmsmoov::GainPair* GainSetCommand::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
      ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainPair& GainSetCommand::_internal_gain_pair() const {
  return _internal_has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : reinterpret_cast< ::fmsmoov::GainPair&>(::fmsmoov::_GainPair_default_instance_);
}
inline const ::fmsmoov::GainPair& GainSetCommand::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain_pair)
  return _internal_gain_pair();
}
inline ::fmsmoov::GainPair* GainSetCommand::unsafe_arena_release_gain_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.GainSetCommand.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GainSetCommand::unsafe_arena_set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.GainSetCommand.gain_pair)
}
inline ::fmsmoov::GainPair* GainSetCommand::_internal_mutable_gain_pair() {
  if (!_internal_has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = CreateMaybeMessage< ::fmsmoov::GainPair >(GetArenaForAllocation());
  }
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainSetCommand::mutable_gain_pair() {
  ::fmsmoov::GainPair* _msg = _internal_mutable_gain_pair();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.gain_pair)
  return _msg;
}

// float gain = 3;
inline bool GainSetCommand::_internal_has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline bool GainSetCommand::has_gain() const {
  return _internal_has_gain();
}
inline void GainSetCommand::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainSetCommand::clear_gain() {
  if (_internal_has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainSetCommand::_internal_gain() const {
  if (_internal_has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainSetCommand::_internal_set_gain(float value) {
  if (!_internal_has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
}
inline float GainSetCommand::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain)
  return _internal_gain();
}
inline void GainSetCommand::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainSetCommand::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainSetCommand::_internal_type() const {
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline ::fmsmoov::GainType GainSetCommand::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.type)
  return _internal_type();
}
inline void GainSetCommand::_internal_set_type(::fmsmoov::GainType value) {
  
  type_ = value;
}
inline void GainSetCommand::set_type(::fmsmoov::GainType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.type)
}

inline bool GainSetCommand::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainSetCommand::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainSetCommand::GaintypeOneofCase GainSetCommand::gaintype_oneof_case() const {
  return GainSetCommand::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GainSetResponse

// .fmsmoov.ResponseCode response = 1;
inline void GainSetResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode GainSetResponse::_internal_response() const {
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline ::fmsmoov::ResponseCode GainSetResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetResponse.response)
  return _internal_response();
}
inline void GainSetResponse::_internal_set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
}
inline void GainSetResponse::set_response(::fmsmoov::ResponseCode value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetResponse.response)
}

// -------------------------------------------------------------------

// GainGetCommand

// string which = 1;
inline void GainGetCommand::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainGetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetCommand.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainGetCommand::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetCommand.which)
}
inline std::string* GainGetCommand::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetCommand.which)
  return _s;
}
inline const std::string& GainGetCommand::_internal_which() const {
  return which_.Get();
}
inline void GainGetCommand::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainGetCommand::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainGetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetCommand.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainGetCommand::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetCommand.which)
}

// -------------------------------------------------------------------

// GainGetResponse

// string which = 1;
inline void GainGetResponse::clear_which() {
  which_.ClearToEmpty();
}
inline const std::string& GainGetResponse::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.which)
  return _internal_which();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GainGetResponse::set_which(ArgT0&& arg0, ArgT... args) {
 
 which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.which)
}
inline std::string* GainGetResponse::mutable_which() {
  std::string* _s = _internal_mutable_which();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.which)
  return _s;
}
inline const std::string& GainGetResponse::_internal_which() const {
  return which_.Get();
}
inline void GainGetResponse::_internal_set_which(const std::string& value) {
  
  which_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GainGetResponse::_internal_mutable_which() {
  
  return which_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GainGetResponse::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.which)
  return which_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GainGetResponse::set_allocated_which(std::string* which) {
  if (which != nullptr) {
    
  } else {
    
  }
  which_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), which,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetResponse.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainGetResponse::_internal_has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline bool GainGetResponse::has_gain_pair() const {
  return _internal_has_gain_pair();
}
inline void GainGetResponse::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainGetResponse::clear_gain_pair() {
  if (_internal_has_gain_pair()) {
    if (GetArenaForAllocation() == nullptr) {
      delete gaintype_oneof_.gain_pair_;
    }
    clear_has_gaintype_oneof();
  }
}
inline ::fmsmoov::GainPair* GainGetResponse::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
      ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainPair& GainGetResponse::_internal_gain_pair() const {
  return _internal_has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : reinterpret_cast< ::fmsmoov::GainPair&>(::fmsmoov::_GainPair_default_instance_);
}
inline const ::fmsmoov::GainPair& GainGetResponse::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain_pair)
  return _internal_gain_pair();
}
inline ::fmsmoov::GainPair* GainGetResponse::unsafe_arena_release_gain_pair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.GainGetResponse.gain_pair)
  if (_internal_has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GainGetResponse::unsafe_arena_set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.GainGetResponse.gain_pair)
}
inline ::fmsmoov::GainPair* GainGetResponse::_internal_mutable_gain_pair() {
  if (!_internal_has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = CreateMaybeMessage< ::fmsmoov::GainPair >(GetArenaForAllocation());
  }
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainGetResponse::mutable_gain_pair() {
  ::fmsmoov::GainPair* _msg = _internal_mutable_gain_pair();
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.gain_pair)
  return _msg;
}

// float gain = 3;
inline bool GainGetResponse::_internal_has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline bool GainGetResponse::has_gain() const {
  return _internal_has_gain();
}
inline void GainGetResponse::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainGetResponse::clear_gain() {
  if (_internal_has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainGetResponse::_internal_gain() const {
  if (_internal_has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainGetResponse::_internal_set_gain(float value) {
  if (!_internal_has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
}
inline float GainGetResponse::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain)
  return _internal_gain();
}
inline void GainGetResponse::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainGetResponse::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainGetResponse::_internal_type() const {
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline ::fmsmoov::GainType GainGetResponse::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.type)
  return _internal_type();
}
inline void GainGetResponse::_internal_set_type(::fmsmoov::GainType value) {
  
  type_ = value;
}
inline void GainGetResponse::set_type(::fmsmoov::GainType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.type)
}

inline bool GainGetResponse::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainGetResponse::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainGetResponse::GaintypeOneofCase GainGetResponse::gaintype_oneof_case() const {
  return GainGetResponse::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorCommand

// .fmsmoov.ShutdownCommand shutdown = 1;
inline bool ProcessorCommand::_internal_has_shutdown() const {
  return cmd_oneof_case() == kShutdown;
}
inline bool ProcessorCommand::has_shutdown() const {
  return _internal_has_shutdown();
}
inline void ProcessorCommand::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void ProcessorCommand::clear_shutdown() {
  if (_internal_has_shutdown()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.shutdown_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::ShutdownCommand* ProcessorCommand::release_shutdown() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_cmd_oneof();
      ::fmsmoov::ShutdownCommand* temp = cmd_oneof_.shutdown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::ShutdownCommand& ProcessorCommand::_internal_shutdown() const {
  return _internal_has_shutdown()
      ? *cmd_oneof_.shutdown_
      : reinterpret_cast< ::fmsmoov::ShutdownCommand&>(::fmsmoov::_ShutdownCommand_default_instance_);
}
inline const ::fmsmoov::ShutdownCommand& ProcessorCommand::shutdown() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.shutdown)
  return _internal_shutdown();
}
inline ::fmsmoov::ShutdownCommand* ProcessorCommand::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_cmd_oneof();
    ::fmsmoov::ShutdownCommand* temp = cmd_oneof_.shutdown_;
    cmd_oneof_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_shutdown(::fmsmoov::ShutdownCommand* shutdown) {
  clear_cmd_oneof();
  if (shutdown) {
    set_has_shutdown();
    cmd_oneof_.shutdown_ = shutdown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.shutdown)
}
inline ::fmsmoov::ShutdownCommand* ProcessorCommand::_internal_mutable_shutdown() {
  if (!_internal_has_shutdown()) {
    clear_cmd_oneof();
    set_has_shutdown();
    cmd_oneof_.shutdown_ = CreateMaybeMessage< ::fmsmoov::ShutdownCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.shutdown_;
}
inline ::fmsmoov::ShutdownCommand* ProcessorCommand::mutable_shutdown() {
  ::fmsmoov::ShutdownCommand* _msg = _internal_mutable_shutdown();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.shutdown)
  return _msg;
}

// .fmsmoov.GainSetCommand gain_set = 2;
inline bool ProcessorCommand::_internal_has_gain_set() const {
  return cmd_oneof_case() == kGainSet;
}
inline bool ProcessorCommand::has_gain_set() const {
  return _internal_has_gain_set();
}
inline void ProcessorCommand::set_has_gain_set() {
  _oneof_case_[0] = kGainSet;
}
inline void ProcessorCommand::clear_gain_set() {
  if (_internal_has_gain_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.gain_set_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::release_gain_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_cmd_oneof();
      ::fmsmoov::GainSetCommand* temp = cmd_oneof_.gain_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainSetCommand& ProcessorCommand::_internal_gain_set() const {
  return _internal_has_gain_set()
      ? *cmd_oneof_.gain_set_
      : reinterpret_cast< ::fmsmoov::GainSetCommand&>(::fmsmoov::_GainSetCommand_default_instance_);
}
inline const ::fmsmoov::GainSetCommand& ProcessorCommand::gain_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_set)
  return _internal_gain_set();
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::unsafe_arena_release_gain_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainSetCommand* temp = cmd_oneof_.gain_set_;
    cmd_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set) {
  clear_cmd_oneof();
  if (gain_set) {
    set_has_gain_set();
    cmd_oneof_.gain_set_ = gain_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.gain_set)
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::_internal_mutable_gain_set() {
  if (!_internal_has_gain_set()) {
    clear_cmd_oneof();
    set_has_gain_set();
    cmd_oneof_.gain_set_ = CreateMaybeMessage< ::fmsmoov::GainSetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.gain_set_;
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::mutable_gain_set() {
  ::fmsmoov::GainSetCommand* _msg = _internal_mutable_gain_set();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_set)
  return _msg;
}

// .fmsmoov.GainGetCommand gain_get = 3;
inline bool ProcessorCommand::_internal_has_gain_get() const {
  return cmd_oneof_case() == kGainGet;
}
inline bool ProcessorCommand::has_gain_get() const {
  return _internal_has_gain_get();
}
inline void ProcessorCommand::set_has_gain_get() {
  _oneof_case_[0] = kGainGet;
}
inline void ProcessorCommand::clear_gain_get() {
  if (_internal_has_gain_get()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_oneof_.gain_get_;
    }
    clear_has_cmd_oneof();
  }
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::release_gain_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_cmd_oneof();
      ::fmsmoov::GainGetCommand* temp = cmd_oneof_.gain_get_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainGetCommand& ProcessorCommand::_internal_gain_get() const {
  return _internal_has_gain_get()
      ? *cmd_oneof_.gain_get_
      : reinterpret_cast< ::fmsmoov::GainGetCommand&>(::fmsmoov::_GainGetCommand_default_instance_);
}
inline const ::fmsmoov::GainGetCommand& ProcessorCommand::gain_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_get)
  return _internal_gain_get();
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::unsafe_arena_release_gain_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorCommand.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainGetCommand* temp = cmd_oneof_.gain_get_;
    cmd_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorCommand::unsafe_arena_set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get) {
  clear_cmd_oneof();
  if (gain_get) {
    set_has_gain_get();
    cmd_oneof_.gain_get_ = gain_get;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorCommand.gain_get)
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::_internal_mutable_gain_get() {
  if (!_internal_has_gain_get()) {
    clear_cmd_oneof();
    set_has_gain_get();
    cmd_oneof_.gain_get_ = CreateMaybeMessage< ::fmsmoov::GainGetCommand >(GetArenaForAllocation());
  }
  return cmd_oneof_.gain_get_;
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::mutable_gain_get() {
  ::fmsmoov::GainGetCommand* _msg = _internal_mutable_gain_get();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_get)
  return _msg;
}

inline bool ProcessorCommand::has_cmd_oneof() const {
  return cmd_oneof_case() != CMD_ONEOF_NOT_SET;
}
inline void ProcessorCommand::clear_has_cmd_oneof() {
  _oneof_case_[0] = CMD_ONEOF_NOT_SET;
}
inline ProcessorCommand::CmdOneofCase ProcessorCommand::cmd_oneof_case() const {
  return ProcessorCommand::CmdOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorResponse

// .fmsmoov.ResponseCode response = 1;
inline void ProcessorResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode ProcessorResponse::_internal_response() const {
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline ::fmsmoov::ResponseCode ProcessorResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.response)
  return _internal_response();
}
inline void ProcessorResponse::_internal_set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
}
inline void ProcessorResponse::set_response(::fmsmoov::ResponseCode value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorResponse.response)
}

// string response_msg = 2;
inline void ProcessorResponse::clear_response_msg() {
  response_msg_.ClearToEmpty();
}
inline const std::string& ProcessorResponse::response_msg() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.response_msg)
  return _internal_response_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessorResponse::set_response_msg(ArgT0&& arg0, ArgT... args) {
 
 response_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorResponse.response_msg)
}
inline std::string* ProcessorResponse::mutable_response_msg() {
  std::string* _s = _internal_mutable_response_msg();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.response_msg)
  return _s;
}
inline const std::string& ProcessorResponse::_internal_response_msg() const {
  return response_msg_.Get();
}
inline void ProcessorResponse::_internal_set_response_msg(const std::string& value) {
  
  response_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcessorResponse::_internal_mutable_response_msg() {
  
  return response_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcessorResponse::release_response_msg() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.response_msg)
  return response_msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcessorResponse::set_allocated_response_msg(std::string* response_msg) {
  if (response_msg != nullptr) {
    
  } else {
    
  }
  response_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response_msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.response_msg)
}

// .fmsmoov.ShutdownResponse shutdown = 3;
inline bool ProcessorResponse::_internal_has_shutdown() const {
  return rsp_oneof_case() == kShutdown;
}
inline bool ProcessorResponse::has_shutdown() const {
  return _internal_has_shutdown();
}
inline void ProcessorResponse::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void ProcessorResponse::clear_shutdown() {
  if (_internal_has_shutdown()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rsp_oneof_.shutdown_;
    }
    clear_has_rsp_oneof();
  }
}
inline ::fmsmoov::ShutdownResponse* ProcessorResponse::release_shutdown() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_rsp_oneof();
      ::fmsmoov::ShutdownResponse* temp = rsp_oneof_.shutdown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rsp_oneof_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::ShutdownResponse& ProcessorResponse::_internal_shutdown() const {
  return _internal_has_shutdown()
      ? *rsp_oneof_.shutdown_
      : reinterpret_cast< ::fmsmoov::ShutdownResponse&>(::fmsmoov::_ShutdownResponse_default_instance_);
}
inline const ::fmsmoov::ShutdownResponse& ProcessorResponse::shutdown() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.shutdown)
  return _internal_shutdown();
}
inline ::fmsmoov::ShutdownResponse* ProcessorResponse::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorResponse.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_rsp_oneof();
    ::fmsmoov::ShutdownResponse* temp = rsp_oneof_.shutdown_;
    rsp_oneof_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorResponse::unsafe_arena_set_allocated_shutdown(::fmsmoov::ShutdownResponse* shutdown) {
  clear_rsp_oneof();
  if (shutdown) {
    set_has_shutdown();
    rsp_oneof_.shutdown_ = shutdown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.shutdown)
}
inline ::fmsmoov::ShutdownResponse* ProcessorResponse::_internal_mutable_shutdown() {
  if (!_internal_has_shutdown()) {
    clear_rsp_oneof();
    set_has_shutdown();
    rsp_oneof_.shutdown_ = CreateMaybeMessage< ::fmsmoov::ShutdownResponse >(GetArenaForAllocation());
  }
  return rsp_oneof_.shutdown_;
}
inline ::fmsmoov::ShutdownResponse* ProcessorResponse::mutable_shutdown() {
  ::fmsmoov::ShutdownResponse* _msg = _internal_mutable_shutdown();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.shutdown)
  return _msg;
}

// .fmsmoov.GainSetResponse gain_set = 4;
inline bool ProcessorResponse::_internal_has_gain_set() const {
  return rsp_oneof_case() == kGainSet;
}
inline bool ProcessorResponse::has_gain_set() const {
  return _internal_has_gain_set();
}
inline void ProcessorResponse::set_has_gain_set() {
  _oneof_case_[0] = kGainSet;
}
inline void ProcessorResponse::clear_gain_set() {
  if (_internal_has_gain_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rsp_oneof_.gain_set_;
    }
    clear_has_rsp_oneof();
  }
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::release_gain_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_rsp_oneof();
      ::fmsmoov::GainSetResponse* temp = rsp_oneof_.gain_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rsp_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainSetResponse& ProcessorResponse::_internal_gain_set() const {
  return _internal_has_gain_set()
      ? *rsp_oneof_.gain_set_
      : reinterpret_cast< ::fmsmoov::GainSetResponse&>(::fmsmoov::_GainSetResponse_default_instance_);
}
inline const ::fmsmoov::GainSetResponse& ProcessorResponse::gain_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.gain_set)
  return _internal_gain_set();
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::unsafe_arena_release_gain_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorResponse.gain_set)
  if (_internal_has_gain_set()) {
    clear_has_rsp_oneof();
    ::fmsmoov::GainSetResponse* temp = rsp_oneof_.gain_set_;
    rsp_oneof_.gain_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorResponse::unsafe_arena_set_allocated_gain_set(::fmsmoov::GainSetResponse* gain_set) {
  clear_rsp_oneof();
  if (gain_set) {
    set_has_gain_set();
    rsp_oneof_.gain_set_ = gain_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.gain_set)
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::_internal_mutable_gain_set() {
  if (!_internal_has_gain_set()) {
    clear_rsp_oneof();
    set_has_gain_set();
    rsp_oneof_.gain_set_ = CreateMaybeMessage< ::fmsmoov::GainSetResponse >(GetArenaForAllocation());
  }
  return rsp_oneof_.gain_set_;
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::mutable_gain_set() {
  ::fmsmoov::GainSetResponse* _msg = _internal_mutable_gain_set();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.gain_set)
  return _msg;
}

// .fmsmoov.GainGetResponse gain_get = 5;
inline bool ProcessorResponse::_internal_has_gain_get() const {
  return rsp_oneof_case() == kGainGet;
}
inline bool ProcessorResponse::has_gain_get() const {
  return _internal_has_gain_get();
}
inline void ProcessorResponse::set_has_gain_get() {
  _oneof_case_[0] = kGainGet;
}
inline void ProcessorResponse::clear_gain_get() {
  if (_internal_has_gain_get()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rsp_oneof_.gain_get_;
    }
    clear_has_rsp_oneof();
  }
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::release_gain_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_rsp_oneof();
      ::fmsmoov::GainGetResponse* temp = rsp_oneof_.gain_get_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rsp_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fmsmoov::GainGetResponse& ProcessorResponse::_internal_gain_get() const {
  return _internal_has_gain_get()
      ? *rsp_oneof_.gain_get_
      : reinterpret_cast< ::fmsmoov::GainGetResponse&>(::fmsmoov::_GainGetResponse_default_instance_);
}
inline const ::fmsmoov::GainGetResponse& ProcessorResponse::gain_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.gain_get)
  return _internal_gain_get();
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::unsafe_arena_release_gain_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fmsmoov.ProcessorResponse.gain_get)
  if (_internal_has_gain_get()) {
    clear_has_rsp_oneof();
    ::fmsmoov::GainGetResponse* temp = rsp_oneof_.gain_get_;
    rsp_oneof_.gain_get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessorResponse::unsafe_arena_set_allocated_gain_get(::fmsmoov::GainGetResponse* gain_get) {
  clear_rsp_oneof();
  if (gain_get) {
    set_has_gain_get();
    rsp_oneof_.gain_get_ = gain_get;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fmsmoov.ProcessorResponse.gain_get)
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::_internal_mutable_gain_get() {
  if (!_internal_has_gain_get()) {
    clear_rsp_oneof();
    set_has_gain_get();
    rsp_oneof_.gain_get_ = CreateMaybeMessage< ::fmsmoov::GainGetResponse >(GetArenaForAllocation());
  }
  return rsp_oneof_.gain_get_;
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::mutable_gain_get() {
  ::fmsmoov::GainGetResponse* _msg = _internal_mutable_gain_get();
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.gain_get)
  return _msg;
}

inline bool ProcessorResponse::has_rsp_oneof() const {
  return rsp_oneof_case() != RSP_ONEOF_NOT_SET;
}
inline void ProcessorResponse::clear_has_rsp_oneof() {
  _oneof_case_[0] = RSP_ONEOF_NOT_SET;
}
inline ProcessorResponse::RspOneofCase ProcessorResponse::rsp_oneof_case() const {
  return ProcessorResponse::RspOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fmsmoov

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fmsmoov::GainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::GainType>() {
  return ::fmsmoov::GainType_descriptor();
}
template <> struct is_proto_enum< ::fmsmoov::ResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::ResponseCode>() {
  return ::fmsmoov::ResponseCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fmsmoov_2eproto
